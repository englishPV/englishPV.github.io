
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <title>Physique Flashcards</title>
  <style>
    /* --- VARIABLES & THEME --- */
:root {
  --bg: #0b1020; --surface: #12172b; --card: #161c33; --text: #e6ecff; --muted: #8aa0d3;
  --primary: #6366f1; --primary-600: #5457e6; --green: #22c55e; --blue: #3b82f6; --amber: #f59e0b; --red: #ef4444;
  --border: #232a48;
  --fs-term: 20px; --fs-def: 24px; --radius-md: 14px;
  --btn-neutral-bg: rgba(255,255,255,.06); --btn-neutral-fg: #e6ecff; --btn-neutral-bd: #232a48; --btn-neutral-bg-h: rgba(255,255,255,.10);
  --btn-soft-primary-bg: color-mix(in srgb,var(--primary) 22%,transparent); --btn-soft-primary-bg-h: color-mix(in srgb,var(--primary) 34%,transparent);
  --btn-soft-primary-fg: #dbe4ff; --btn-soft-primary-bd: color-mix(in srgb,var(--primary) 55%,transparent);
  --btn-soft-red-bg: rgba(239,68,68,.18); --btn-soft-red-bg-h: rgba(239,68,68,.28); --btn-soft-red-fg: #fecaca; --btn-soft-red-bd: rgba(239,68,68,.45);
  --btn-soft-amber-bg: rgba(245,158,11,.18); --btn-soft-amber-bg-h: rgba(245,158,11,.28); --btn-soft-amber-fg: #fde68a; --btn-soft-amber-bd: rgba(245,158,11,.45);
  --btn-soft-blue-bg: rgba(59,130,246,.18); --btn-soft-blue-bg-h: rgba(59,130,246,.28); --btn-soft-blue-fg: #bfdbfe; --btn-soft-blue-bd: rgba(59,130,246,.45);
  --btn-soft-green-bg: rgba(34,197,94,.18); --btn-soft-green-bg-h: rgba(34,197,94,.28); --btn-soft-green-fg: #bbf7d0; --btn-soft-green-bd: rgba(34,197,94,.45);
  --btn-solid-primary-bg: var(--primary); --btn-solid-primary-bg-h: var(--primary-600); --btn-solid-primary-fg: #fff; --btn-solid-primary-bd: var(--primary-600);
}
[data-theme="light"] {
  --bg: linear-gradient(180deg,#f8fafc 0%,#eef2f7 100%); --surface: #fff; --card: #fff; --text: #0f172a; --muted: #475569;
  --primary: #3b82f6; --primary-600: #2563eb; --border: #cbd5e1;
  --btn-neutral-bg: #f1f5f9; --btn-neutral-fg: #0f172a; --btn-neutral-bd: #cbd5e1; --btn-neutral-bg-h: #e2e8f0;
  --btn-soft-primary-bg: color-mix(in srgb,var(--primary) 14%,white 86%); --btn-soft-primary-bg-h: color-mix(in srgb,var(--primary) 22%,white 78%);
  --btn-soft-primary-fg: color-mix(in srgb,var(--primary) 78%,black 22%); --btn-soft-primary-bd: color-mix(in srgb,var(--primary) 35%,white 65%);
  --btn-soft-red-bg: #fee2e2; --btn-soft-red-bg-h: #fecaca; --btn-soft-red-fg: #991b1b; --btn-soft-red-bd: #fca5a5;
  --btn-soft-amber-bg: #fef3c7; --btn-soft-amber-bg-h: #fde68a; --btn-soft-amber-fg: #92400e; --btn-soft-amber-bd: #fcd34d;
  --btn-soft-blue-bg: #dbeafe; --btn-soft-blue-bg-h: #bfdbfe; --btn-soft-blue-fg: #1e3a8a; --btn-soft-blue-bd: #93c5fd;
  --btn-soft-green-bg: #dcfce7; --btn-soft-green-bg-h: #bbf7d0; --btn-soft-green-fg: #14532d; --btn-soft-green-bd: #86efac;
}
[data-theme="light"] :is(.definition,.card-item .back){color:var(--text)!important;opacity:1!important}
[data-theme="light"] .muted{color:#475569!important}
[data-theme="light"] .legend-item{color:#0f172a!important;border-color:#e2e8f0!important;background:0 0!important}
[data-theme="light"] :is(.revision-bar,.review-actions-bar){background:rgba(241,245,249,.9)!important;border-top:1px solid #e2e8f0!important}
[data-theme="light"] .btn--ghost{--btn-bg-h:rgba(0,0,0,.06)}

/* --- RESET & LAYOUT --- */
* { box-sizing: border-box; }
html, body { height: 100%; }
body { margin: 0; background: var(--bg); color: var(--text); font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif; overflow: hidden; font-size: 17px; -webkit-font-smoothing: antialiased; }
.wrapper { height: 100dvh; width: 100%; display: flex; align-items: center; justify-content: center; padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left); }
.phone { aspect-ratio: 9/16; height: 100%; width: auto; max-width: 100%; max-height: 100%; display: grid; grid-template-rows: var(--row-top,52px) var(--row-main,1fr) var(--row-actions,52px) var(--row-rev,64px); position: relative; min-height: 0; touch-action: pan-y; overflow: hidden; }
@media(min-width: 1024px) { .phone { aspect-ratio: auto; width: 100%; height: 100dvh; } .topbar, main#view, .bottom-actions, .revision-bar { max-width: 1200px; margin: 0 auto; width: 100%; } main#view { padding: 16px 20px; } }

/* --- COMPONENTS --- */
.topbar { position: sticky; top: 0; z-index: 10; display: flex; align-items: center; padding: 0 10px; }
.topbar .back { appearance: none; border: 0; outline: 0; background: 0 0; color: var(--text); padding: 8px 10px; margin-right: 4px; border-radius: 10px; display: flex; align-items: center; gap: 8px; cursor: pointer; font-weight: 700; }
.topbar .back:hover { background: rgba(255,255,255,.06); }
.topbar .title { font-weight: 800; font-size: 16px; margin-left: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; cursor: pointer; }
.spacer { flex: 1; }

main#view { min-height: 0; height: 100%; display: flex; flex-direction: column; overflow: hidden; padding: 8px; gap: 10px; }
.hidden { display: none!important; }
.muted { color: var(--muted); }
.center { text-align: center; }
.mt6 { margin-top: 6px; }
.mt8 { margin-top: 8px; }
.scroll-y { overflow: auto; -webkit-overflow-scrolling: touch; overscroll-behavior: contain; touch-action: pan-y; } .scroll-lock { overflow: hidden; touch-action: none!important; }
.list, .flexcol { display: flex; flex-direction: column; gap: 8px; min-height: 0; } .stack { display: flex; flex-direction: column; gap: 6px; }
.row { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
.grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
.row-4 { display: grid; grid-template-columns: repeat(4,1fr); gap: 8px; }
.input { width: 100%; padding: 8px 10px; border-radius: 10px; border: 1px solid var(--border); background: var(--surface); color: var(--text); font-size: 14px; outline: none; appearance: none; }
.input:focus { border-color: var(--primary); }

.card,.deck-item,.review-card,.legend-item,.kpi .k,.stat,.chip{background:0 0;border:0;border-radius:var(--radius-md)}

/* Deck & Lists */
.deck-item { display: flex; align-items: center; justify-content: space-between; padding: 0 8px; cursor: pointer; user-select: none; position: relative; overflow: hidden; touch-action: pan-y; border-bottom: 1px solid color-mix(in srgb, var(--border) 50%, transparent); pointer-events: auto; }
.deck-item:last-child { border-bottom: none; }
.deck-item .slide { display: flex; align-items: center; gap: 10px; padding: 12px 0; transition: transform .18s ease; will-change: transform; width: 100%; position: relative; z-index: 2; }
.deck-item .right-action { position: absolute; top: 0; right: 0; height: 100%; width: 92px; display: flex; align-items: center; justify-content: center; z-index: 1; }
.deck-item.reveal-delete .slide { transform: translateX(-92px); }
.deck-item.drop-target { outline: 2px dashed var(--primary); outline-offset: -2px; border-radius: var(--radius-md); background: color-mix(in srgb,var(--primary) 8%,transparent); }
.deck-item.drop-target-above::before { content:''; position:absolute; top:-2px; left:10px; right:10px; height:3px; background:var(--primary); border-radius:2px; z-index:10; }
.deck-item.drop-target-below::after { content:''; position:absolute; bottom:-2px; left:10px; right:10px; height:3px; background:var(--primary); border-radius:2px; z-index:10; }
.deck-item.drop-target-inside { background: color-mix(in srgb,var(--primary) 15%,transparent); outline: 2px solid var(--primary); }
.deck-item.dragging-origin { opacity: .3; }
.drag-ghost { position: fixed; left: 0; top: 0; pointer-events: none; z-index: 9999; transform: translate(-9999px,-9999px) scale(1.02); box-shadow: 0 10px 30px rgba(0,0,0,.35); background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-md); padding: 10px 16px; font-weight: 700; font-size: 14px; color: var(--text); max-width: 250px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

.folder-badge { font-weight: bold; color: var(--primary); margin-left: 6px; font-size: 12px; }

/* Selection mode checkbox */
.sel-checkbox { width: 22px; height: 22px; border-radius: 6px; border: 2px solid var(--border); background: transparent; cursor: pointer; display: flex; align-items: center; justify-content: center; flex-shrink: 0; transition: all 0.2s; margin-right: 8px; }
.sel-checkbox.checked { background: var(--primary); border-color: var(--primary); }
.sel-checkbox.checked::after { content: '‚úì'; color: #fff; font-size: 14px; font-weight: bold; }

/* Red X button for removing from folder */
.remove-x { width: 26px; height: 26px; border-radius: 50%; background: rgba(239,68,68,0.15); border: 1px solid rgba(239,68,68,0.4); color: var(--red); font-size: 14px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; flex-shrink: 0; transition: all 0.15s; }
.remove-x:hover { background: rgba(239,68,68,0.3); }

/* Confirm FAB */
.fab-confirm { position: fixed; bottom: calc(20px + env(safe-area-inset-bottom)); right: 20px; width: 56px; height: 56px; border-radius: 50%; background: var(--green); color: #fff; border: none; font-size: 24px; cursor: pointer; box-shadow: 0 4px 16px rgba(34,197,94,0.4); z-index: 100; display: flex; align-items: center; justify-content: center; transition: transform 0.2s, opacity 0.2s; }
.fab-confirm:active { transform: scale(0.9); }
.fab-cancel { position: fixed; bottom: calc(20px + env(safe-area-inset-bottom)); left: 20px; width: 56px; height: 56px; border-radius: 50%; background: var(--red); color: #fff; border: none; font-size: 20px; cursor: pointer; box-shadow: 0 4px 16px rgba(239,68,68,0.4); z-index: 100; display: flex; align-items: center; justify-content: center; transition: transform 0.2s; }
.fab-cancel:active { transform: scale(0.9); }

/* Indented folder children */
.deck-item.folder-child { padding-left: 28px; }
.deck-item.folder-child-depth-2 { padding-left: 48px; }
.deck-item.folder-child-depth-3 { padding-left: 68px; }

/* Deck emoji avatar */
.deck-emoji { width: 42px; height: 42px; border-radius: 12px; background: color-mix(in srgb, var(--primary) 15%, transparent); display: flex; align-items: center; justify-content: center; font-size: 20px; flex-shrink: 0; }
.deck-info { min-width: 0; flex: 1; }
.deck-info .deck-title { font-weight: 800; font-size: 15px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.deck-info .deck-sub { display: flex; align-items: center; gap: 8px; margin-top: 3px; font-size: 12px; color: var(--muted); }
.deck-info .deck-sub .mini-bar { width: 50px; height: 4px; border-radius: 2px; background: var(--border); overflow: hidden; flex-shrink: 0; }
.deck-info .deck-sub .mini-bar-fill { height: 100%; border-radius: 2px; background: var(--primary); transition: width 0.3s; }
.deck-info .deck-sub .mini-dots { display: flex; gap: 3px; }
.deck-info .deck-sub .mini-dots .md { width: 7px; height: 7px; border-radius: 50%; }
.deck-chevron { color: var(--muted); font-size: 16px; opacity: 0.5; padding-left: 6px; }

/* Stats row: chart + bar7 side by side */
.stats-row { display: flex; align-items: center; gap: 10px; margin: 0; }
.chart-wrap { display: flex; align-items: center; justify-content: center; height: auto; position: relative; z-index: 1; flex-shrink: 0; }
canvas#gradeChart { width: 140px; height: 140px; pointer-events: auto; }
.bar7-side { flex: 1; display: flex; flex-direction: column; gap: 2px; min-width: 0; }
.bar7-row { display: flex; align-items: center; gap: 6px; font-size: 11px; color: var(--muted); height: 18px; cursor: pointer; }
.bar7-row .bar7-label { width: 28px; text-align: right; flex-shrink: 0; font-weight: 600; }
.bar7-row .bar7-track { flex: 1; height: 10px; background: var(--border); border-radius: 5px; overflow: hidden; position: relative; }
.bar7-row .bar7-fill { height: 100%; border-radius: 5px; background: var(--primary); transition: width 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); }
.bar7-row .bar7-val { width: 20px; text-align: left; flex-shrink: 0; font-weight: 700; font-size: 10px; }

/* Stats grid */
.stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
.stat-card { padding: 10px 12px; border-radius: 10px; background: color-mix(in srgb, var(--border) 30%, transparent); }
.stat-card .stat-val { font-weight: 900; font-size: 20px; }
.stat-card .stat-lbl { font-size: 11px; color: var(--muted); margin-top: 1px; }

/* Section title */
.section-title { font-weight: 900; font-size: 14px; color: var(--primary); letter-spacing: .3px; margin: 0 0 6px; }

/* KPI */
.kpi { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; } .kpi .k { padding: 0; pointer-events: auto; } .k .label, .stat .label { color: var(--muted); font-size: 12px; } .k .value, .val { font-weight: 900; font-size: 17px; margin-top: 2px; }
.chip { display: inline-flex; align-items: center; gap: 8px; padding: 0; color: var(--muted); font-size: 12px; pointer-events: auto; }
.chip-pie { width: 18px; height: 18px; border-radius: 50%; background: conic-gradient(var(--primary) var(--progress,0%),var(--border) var(--progress,0%)); vertical-align: middle; display: inline-block; }

/* Legend compact */
.legend { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; }
.legend-item { display: flex; align-items: center; gap: 4px; font-size: 12px; padding: 3px 8px; border-radius: 8px; background: color-mix(in srgb, var(--border) 30%, transparent); cursor: pointer; user-select: none; transition: opacity .15s; position: relative; z-index: 2; pointer-events: auto; }
.legend-item.inactive { opacity: .45; filter: grayscale(20%); }
.dot { width: 10px; height: 10px; border-radius: 50%; } .dot.gray { background: #9ca3af; } .dot.red { background: var(--red); } .dot.amber { background: var(--amber); } .dot.blue { background: var(--blue); } .dot.green { background: var(--green); }

main#view > .card { overflow-y: auto; -webkit-overflow-scrolling: touch; min-height: 0; pointer-events: auto; }

/* Review */
.review-wrap { position: relative; flex: 1; display: flex; flex-direction: column; min-height: 0; overflow: hidden; }
.review-top { display: flex; justify-content: space-between; color: var(--muted); font-size: 13px; flex-shrink: 0; padding-bottom: 4px; }
.review-card { flex: 1; display: flex; flex-direction: column; position: relative; overflow: hidden; min-height: 0; padding: 0; transition: background-color 0.4s ease; pointer-events: auto; }

.review-scroller { flex: 1; width: 100%; height: 100%; overflow-y: auto; overflow-x: hidden; -webkit-overflow-scrolling: touch; display: flex; flex-direction: column; padding: 10px; touch-action: pan-y; user-select: text; }
.review-scroller > * { margin-top: auto; margin-bottom: auto; width: 100%; }
.term, .definition { font-size: var(--fs-term)!important; font-weight: 600; text-align: center; white-space: pre-wrap; word-wrap: break-word; }
.definition { font-size: var(--fs-def)!important; font-weight: 900; }

.preview-box { background: var(--card); border: 2px dashed var(--border); border-radius: 14px; margin: 10px 14px; padding: 20px; text-align: center; min-height: 120px; display: flex; flex-direction: column; justify-content: center; gap: 15px; }
.preview-recto { font-size: var(--fs-term); font-weight: 600; color: var(--text); }
.preview-verso { font-size: var(--fs-def); font-weight: 900; color: var(--primary); border-top: 1px dashed var(--border); padding-top: 10px; }

/* MathJax & Img */
mjx-container { overflow: hidden; max-width: 100% !important; display: inline-block !important; padding: 4px 0; white-space: normal !important; vertical-align: middle; }
mjx-mtext { white-space: normal !important; display: inline !important; }
mjx-math { white-space: normal !important; max-width: 100%; }
.img-placeholder { display: block; background: rgba(255,255,255,0.05); color: #8aa0d3; padding: 15px; border: 2px dashed rgba(255,255,255,0.1); border-radius: 8px; margin: 15px auto; font-style: italic; font-size: 0.85rem; text-align: center; }
img { display: block; max-width: 100%; height: auto; margin: 10px auto; border-radius: 8px; background: var(--border); user-select: none; object-fit: contain; opacity: 1 !important; }

.bottom-actions, .revision-bar, .review-actions-bar { padding: 8px 10px calc(8px + env(safe-area-inset-bottom)); display: none; background: 0 0; border-top: 0; }
.bottom-actions { gap: 8px; grid-template-columns: 1fr 1fr; } .review-actions-bar { grid-row: 4; backdrop-filter: blur(8px) saturate(140%); }

.btn, .action, .rev-btn { background: var(--btn-bg,var(--btn-neutral-bg)); color: var(--btn-fg,var(--btn-neutral-fg)); border: 1px solid var(--btn-bd,var(--btn-neutral-bd)); border-radius: var(--radius-md); padding: 10px 12px; font-weight: 900; cursor: pointer; transition: .15s; width: 100%; appearance: none; outline: 0; font-size: 15px; }
.btn:hover { background: var(--btn-bg-h,var(--btn-bg,var(--btn-neutral-bg-h))); } .btn:disabled { opacity: .6; cursor: not-allowed; }
.btn--primary { --btn-bg: var(--btn-soft-primary-bg); --btn-bg-h: var(--btn-soft-primary-bg-h); --btn-fg: var(--btn-soft-primary-fg); --btn-bd: var(--btn-soft-primary-bd); }
.btn--red { --btn-bg: var(--btn-soft-red-bg); --btn-bg-h: var(--btn-soft-red-bg-h); --btn-fg: var(--btn-soft-red-fg); --btn-bd: var(--btn-soft-red-bd); }
.btn--amber { --btn-bg: var(--btn-soft-amber-bg); --btn-bg-h: var(--btn-soft-amber-bg-h); --btn-fg: var(--btn-soft-amber-fg); --btn-bd: var(--btn-soft-amber-bd); }
.btn--blue { --btn-bg: var(--btn-soft-blue-bg); --btn-bg-h: var(--btn-soft-blue-bg-h); --btn-fg: var(--btn-soft-blue-fg); --btn-bd: var(--btn-soft-blue-bd); }
.btn--green { --btn-bg: var(--btn-soft-green-bg); --btn-bg-h: var(--btn-soft-green-bg-h); --btn-fg: var(--btn-soft-green-fg); --btn-bd: var(--btn-soft-green-bd); }
.btn--solid.btn--primary { --btn-bg: var(--btn-solid-primary-bg); --btn-bg-h: var(--btn-solid-primary-bg-h); --btn-fg: var(--btn-solid-primary-fg); --btn-bd: var(--btn-solid-primary-bd); }
.btn--ghost { --btn-bg: transparent; --btn-bg-h: rgba(255,255,255,.06); --btn-fg: var(--muted); --btn-bd: var(--border); } .btn--tiny { padding: 6px 8px; font-size: 13px; border-radius: 8px; }

.cards-grid { display: grid; grid-template-columns: 1fr; gap: 10px; } @media(min-width: 480px) { .cards-grid { grid-template-columns: 1fr 1fr; } }
.card-block { position: relative; border: 2px solid transparent; border-radius: 14px; padding: 14px; background: 0 0; max-height: none; overflow: hidden; display: flex; flex-direction: column; }
.card-block .term, .card-block .definition { margin: auto 0; width: 100%; word-break: break-word; }
.card-block .definition { display: none; text-align: center; margin-top: 6px; } .card-block.flipped .definition { display: block; } .card-block .term { text-align: center; }
.cb-time { position: absolute; right: 10px; bottom: 8px; font-size: 12px; color: var(--muted); }
.card-block.grade-echec { border-color: var(--red); } .card-block.grade-difficile { border-color: var(--amber); } .card-block.grade-bien { border-color: var(--blue); } .card-block.grade-facile { border-color: var(--green); } .card-block.grade-unseen { border-color: #9ca3af; }

.subject-menu { position: absolute; top: 52px; left: 10px; background: var(--surface); color: var(--text); border: 1px solid var(--border); border-radius: var(--radius-md); min-width: 220px; box-shadow: 0 10px 30px rgba(0,0,0,.35); padding: 6px; z-index: 1000; display: none; }
.subject-item { display: flex; align-items: center; gap: 8px; padding: 8px 10px; border-radius: 10px; cursor: pointer; } .subject-item:hover { background: rgba(255,255,255,.06); } .subject-item .name { font-weight: 800; flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; } .subject-item .meta { font-size: 12px; color: var(--muted); } .subject-item .subject-actions { margin-left: auto; display: flex; gap: 6px; }
.swatches { display: flex; gap: 8px; flex-wrap: wrap; } .swatch { width: 26px; height: 26px; border-radius: 8px; border: 1px solid var(--border); background: var(--sw,#6366f1); cursor: pointer; position: relative; } .swatch.is-active::after { content: ''; position: absolute; inset: -3px; border: 2px solid var(--primary); border-radius: 10px; }
.img-lightbox { position: fixed; inset: 0; display: none; background: 0 0; z-index: 10000; } .img-lightbox.open { display: block; }
.img-stage { position: absolute; inset: 0; width: 100%; height: 100%; overflow: hidden; touch-action: none; cursor: grab; } .img-canvas { position: absolute; top: 0; left: 0; transform-origin: 0 0; will-change: transform; }

.s-control { display: flex; align-items: center; gap: 15px; padding: 0 14px 15px; }
.s-slider-container { flex: 1; display: flex; align-items: center; height: 40px; position: relative; }
.s-slider { -webkit-appearance: none; appearance: none; width: 100%; height: 6px; background: var(--border); border-radius: 3px; outline: none; cursor: grab; }
.s-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 22px; height: 22px; background: var(--primary); border-radius: 50%; cursor: pointer; border: 3px solid var(--surface); box-shadow: 0 1px 3px rgba(0,0,0,0.3); margin-top: 0; position: relative; z-index: 2; }
.step-btn { width: 32px; height: 32px; border-radius: 6px; border: none; background: var(--surface); color: var(--text); font-size: 18px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; }
.step-btn:active { transform: scale(0.9); background: var(--primary); color: #fff; }

.settings-page { padding: 0 12px; }
.settings-hero { font-size: 28px; font-weight: 900; padding: 16px 4px 12px; }
.settings-section { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; margin-bottom: 14px; overflow: hidden; }
.settings-section .section-title { padding: 10px 14px 6px; font-size: 12px; text-transform: uppercase; letter-spacing: 0.4px; color: var(--muted); margin: 0; }
.settings-row { display: flex; align-items: center; padding: 11px 14px; border-bottom: 1px solid var(--border); gap: 12px; cursor: pointer; transition: background 0.15s; }
.settings-row:last-child { border-bottom: none; }
.settings-row:active { background: rgba(255,255,255,0.04); }
.settings-row .s-icon { width: 30px; height: 30px; border-radius: 7px; display: flex; align-items: center; justify-content: center; font-size: 16px; flex-shrink: 0; color: #fff; }
.s-icon.dynamic { background: var(--primary) !important; transition: background 0.3s ease; }
.s-icon.danger { background: var(--red) !important; }
.settings-row .s-label { flex: 1; min-width: 0; }
.settings-row .s-title { font-weight: 600; font-size: 15px; }
.settings-row .s-sub { font-size: 12px; color: var(--muted); margin-top: 1px; }
.settings-row .s-value { color: var(--muted); font-size: 14px; }
.settings-row .s-chevron { color: var(--muted); font-size: 16px; opacity: 0.6; }
.s-toggle { width: 48px; height: 28px; border-radius: 14px; background: var(--border); position: relative; cursor: pointer; transition: background 0.2s; flex-shrink: 0; }
.s-toggle.on { background: var(--primary); }
.s-toggle::after { content: ''; position: absolute; width: 24px; height: 24px; border-radius: 50%; background: #fff; top: 2px; left: 2px; transition: transform 0.2s; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
.s-toggle.on::after { transform: translateX(20px); }
.settings-section .swatches { padding: 0; gap: 6px; }
.settings-section .swatch { width: 24px; height: 24px; }
.settings-footer { text-align: center; padding: 20px; color: var(--muted); font-size: 12px; }
.toast { position: fixed; bottom: calc(80px + env(safe-area-inset-bottom)); left: 50%; transform: translateX(-50%) translateY(100px); background: var(--surface); color: var(--text); padding: 12px 20px; border-radius: 12px; border: 1px solid var(--border); box-shadow: 0 8px 32px rgba(0,0,0,0.3); font-weight: 600; font-size: 14px; z-index: 9999; opacity: 0; transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.3s; pointer-events: none; max-width: 90%; text-align: center; }
.toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }
.toast.success { border-left: 4px solid var(--green); } .toast.error { border-left: 4px solid var(--red); } .toast.info { border-left: 4px solid var(--primary); }

.progress-bar { position: absolute; top: 0; left: 0; height: 3px; background: linear-gradient(90deg, var(--primary), var(--green)); border-radius: 0 3px 3px 0; transition: width 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); z-index: 5; }

.card-block,.deck-item{transition:transform .2s,border-color .2s,box-shadow .2s,background-color .3s}
.card-block:active,.deck-item:active{transform:scale(.98)}

.focus-mode .topbar, .focus-mode .review-top { opacity: 0.3; transition: opacity 0.3s; }
.focus-mode .topbar:hover, .focus-mode .review-top:hover { opacity: 1; }

/* Math label (less bold) */
.math-label { color: var(--primary); font-weight: 600; font-size: 0.93em; display: block; margin-top: 10px; margin-bottom: 2px; opacity: 0.8; }
</style>
</head>
<body>
  <div class="wrapper">
    <div class="phone" id="app">
       <header class="topbar">
        <button class="back" id="backBtn" title="Retour">‚Üê Retour</button>
        <div class="title" id="title">Deck</div>
        <div class="spacer"></div>
        <a href="https://schedulepv.web.app/" target="_blank" rel="noopener" class="btn btn--primary btn--tiny" style="flex-shrink:0;text-decoration:none;width:auto;padding:6px 12px;">üìÖ</a>
      </header>
      <main id="view"></main>
      <div class="bottom-actions" id="bottomActions">
        <button class="action btn" id="cardsBtn">Cartes</button>
        <button class="action btn" id="settingsBtn">Param√®tres</button>
      </div>
      <footer class="revision-bar" id="revisionBar">
        <button id="startReviewBtn" class="rev-btn btn btn--solid btn--primary">R√©vision</button>
      </footer>
      <footer id="reviewActionsBar" class="review-actions-bar" aria-live="polite"></footer>
    </div>
  </div>

<script src="data.js"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<script>
/* --- CORE APP LOGIC --- */
const D = document, W = window, LS = localStorage, M = Math, KEY = 'flashcards9x16_data', APP_VER = '2026-06-22-math-v4';

const GRADES = ['unseen','echec','difficile','bien','facile'];
const GRADE_INIT = () => Object.fromEntries(GRADES.map(g=>[g,0]));
const GRADE_FILTERS = () => Object.fromEntries(GRADES.map(g=>[g,!0]));
const GC={unseen:'gray',echec:'red',difficile:'amber',bien:'blue',facile:'green'};
const GB={echec:'btn--red',difficile:'btn--amber',bien:'btn--blue',facile:'btn--green'};
const mkCard=(id,f,b,ms=null)=>({id,front:f,back:b,mathSimple:ms,grade:'unseen',timesReviewed:0,lastReviewed:0,lastMs:0,avgMs:0,perfEma:.5,ef:2.5,intervalDays:0,dueAt:0,streak:0,successes:0,failures:0});
const mkStats=n=>({gradeCounts:{...GRADE_INIT(),unseen:n},totalReviews:0,dailyReviews:{},dailyChanges:{},dailyDurMs:{},dailyDurCount:{},dailyLog:{}});
const mkSettings=()=>({sessionSize:10,dailyGoal:10,reviewOrder:'front-first',langSwap:!1});
const mkChapter=(id,title,cards,imp)=>({id,title,description:(getEmoji(title)?getEmoji(title)+' ':'')+title,settings:mkSettings(),filters:{grades:GRADE_FILTERS()},stats:mkStats(cards.length),cards,imported:!!imp});
const sRow=(id,icon,title,sub,right,click)=>`<div class="settings-row" ${id?'id="'+id+'"':''}${click?' style="cursor:pointer"':''}><div class="s-icon dynamic">${icon}</div><div class="s-label"><div class="s-title">${title}</div>${sub?'<div class="s-sub">'+sub+'</div>':''}</div>${right||''}</div>`;
const sToggle=on=>`<div class="s-toggle ${on?'on':''}"></div>`;
const sChev=`<div class="s-chevron">‚Ä∫</div>`;
const sVal=v=>`<div class="s-value">${v}</div>`;

const $ = (s,p=D) => p.querySelector(s), $$ = (s,p=D) => [...p.querySelectorAll(s)];
const clamp = (n,mn,mx) => n<mn?mn:n>mx?mx:n;

const slugify = s => s.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'').replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,'');
const dateKey=d=>`${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`,todayKey=()=>dateKey(new Date()),getDayStart=()=>new Date().setHours(0,0,0,0),avg=a=>a?.length?a.reduce((x,y)=>x+y,0)/a.length:0,deepClone=o=>JSON.parse(JSON.stringify(o)),isSucc=g=>g==='facile'||g==='bien';

let mathCache = new Set();
const clearMathCache = () => { mathCache = new Set(); };

const needsMath = s => /[$]|\\[(\[]|\\frac|\\sqrt|\\text/.test(s);
const tsLat = e => { 
  if(!W.MathJax?.typesetPromise || (e && !needsMath(e.innerHTML))) return Promise.resolve();
  const id = e?.id || e?.dataset?.id;
  if(id) { if(mathCache.has(id)) return Promise.resolve(); mathCache.add(id); }
  return W.MathJax.typesetPromise(e?[e]:null).catch(()=>{});
};
const getEmoji = t => (typeof C_EMOJIS !== 'undefined' ? C_EMOJIS[t] : '') || '';
const isMathChapter = () => { const s=getSub(); return s?.title.toLowerCase()==='maths'; };
const getMathSimple = card => card.mathSimple || null;

const md2html = s => s
    .replace(/\*\*([^*]+?:)\*\*/g, '<span class="math-label">$1</span>')
    .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
    .replace(/(?<!\*)\*(?!\s)(.+?)(?<!\s)\*(?!\*)/g, '<em>$1</em>')
    .replace(/^\s*[\*\-]\s{2,}/gm, '‚Ä¢ ')
    .replace(/\n/g, '<br>');

const parseMathData = (raw) => {
    if (!raw) return [];
    const result = []; let idCounter = 0;
    const chapSplit = raw.split(/^#\s+CHAPITRE\s+(\d+)\s*[‚Äî‚Äì-]\s*(.+)$/gm);
    for (let i = 1; i + 2 < chapSplit.length; i += 3) {
        const chNum = chapSplit[i].trim();
        const chKey = 'CH' + chNum;
        const chTitle = typeof MATH_MAP !== 'undefined' && MATH_MAP[chKey] ? MATH_MAP[chKey].title : chapSplit[i+1].trim();
        const content = chapSplit[i+2];
        const cardSplit = content.split(/^##\s+FLASHCARD\s+\d+\s*[‚Äî‚Äì-]\s*.+$/gm);
        for (let j = 1; j < cardSplit.length; j++) {
            const block = cardSplit[j];
            const rectoMatch = block.match(/###\s+RECTO\s*\n([\s\S]*?)(?=###\s+VERSO|$)/);
            const versoMatch = block.match(/###\s+VERSO\s*\n([\s\S]*?)(?=###\s+L[''']≈íIL|---\s*$|$)/);
            const oeilMatch = block.match(/###\s+L[''']≈íIL DE L[''']X\s*\n([\s\S]*?)(?=---\s*$|$)/);
            if (!rectoMatch) continue;
            let front = rectoMatch[1].trim();
            let back = (versoMatch ? versoMatch[1].trim() : '');
            if (oeilMatch) back += '\n\n---\n\n**üîç L\'≈íil de l\'X :**\n\n' + oeilMatch[1].trim();
            let mathSimple = null;
            const hypoM = back.match(/\*\*Hypoth√®ses compl√®tes\s*:\*\*\s*([\s\S]*?)(?=\*\*√ânonc√© formel|$)/);
            const enonceM = back.match(/\*\*√ânonc√© formel\s*:\*\*\s*([\s\S]*?)(?=\*\*D√©monstration|\*\*Subtilit√©s|\*\*Extensions|\*\*Pi√®ges|\*\*üîç|###|$)/);
            const hText = hypoM ? hypoM[1].trim() : '';
            const eText = enonceM ? enonceM[1].trim() : '';
            if (hText || eText) {
                mathSimple = md2html(hText + (hText && eText ? '\n\n' : '') + eText);
            }
            result.push({
                id: 'math-' + (idCounter++),
                front: md2html(front),
                back: md2html(back),
                mathSimple: mathSimple,
                chapter: chTitle
            });
        }
    }
    return result;
};
const extractId = c => String(c).match(/-(\d+)$/)?.[1]||null;
const getSides = (c,ch) => ch?.settings?.langSwap ? {f:c.back,b:c.front} : {f:c.front,b:c.back};
const fmtDur=ms=>{const s=M.round(ms/1e3);return`${s/60|0}:${String(s%60).padStart(2,'0')}`},fmtDayFR=k=>{const[Y,Mo,Dy]=k.split('-').map(Number),d=new Date(Y,Mo-1,Dy);return`${['Dim','Lun','Mar','Mer','Jeu','Ven','Sam'][d.getDay()]} ${String(Dy).padStart(2,'0')} ${['janv.','f√©vr.','mars','avr.','mai','juin','juil.','ao√ªt','sept.','oct.','nov.','d√©c.'][Mo-1]} ${Y}`};

/* --- UI/UX HELPERS --- */
function toast(msg, type='info', dur=2500) {
  let el = $('#toast') || Object.assign(D.createElement('div'), {id:'toast'});
  if(!el.parentNode) D.body.appendChild(el);
  el.textContent = msg; el.className = `toast ${type}`;
  requestAnimationFrame(() => { el.classList.add('show'); setTimeout(() => el.classList.remove('show'), dur); });
}

const haptic = (s='light') => navigator.vibrate?.({light:10,medium:20,heavy:30,success:[10,50,10],error:[30,50,30]}[s]||10);

function getStreak(c) {
  let streak = 0; const today = new Date();
  for(let i = 0; i < 365; i++) {
    const d = new Date(today); d.setDate(today.getDate() - i);
    if(c.stats.dailyReviews[dateKey(d)] > 0) streak++; else if(i) break;
  }
  return streak;
}

function bindPullRefresh(container, onRefresh) {
  let startY = 0, pulling = false, indicator = null;
  container.addEventListener('touchstart', e => { if(container.scrollTop <= 5) { startY = e.touches[0].clientY; pulling = true; } }, {passive:!0});
  container.addEventListener('touchmove', e => {
    if(!pulling) return; const delta = e.touches[0].clientY - startY;
    if(delta > 0 && delta < 120) {
      if(!indicator) { indicator = D.createElement('div'); indicator.innerHTML = '‚Üª'; indicator.style.cssText = 'text-align:center;padding:10px;color:var(--muted);font-size:20px;transition:transform 0.2s'; container.prepend(indicator); }
      indicator.style.transform = `rotate(${delta * 3}deg)`;
    }
  }, {passive:!0});
  container.addEventListener('touchend', e => {
    if(indicator) { if(e.changedTouches[0].clientY - startY > 80) { haptic('medium'); onRefresh(); } indicator.remove(); indicator = null; }
    pulling = false;
  });
}

const hasSelection = () => window.getSelection()?.toString().length > 0;

function bindSwipeNav() {
  const wrap = $('.review-wrap'); if(!wrap) return;
  const card = wrap.querySelector('.review-card'); if(!card) return;
  const scroller = wrap.querySelector('.review-scroller');

  let startX = 0, startY = 0, deltaX = 0;
  let mode = 'idle';

  wrap.addEventListener('touchstart', e => {
    if(e.touches.length !== 1 || mode === 'animating') return;
    if(hasSelection()) { mode = 'selecting'; return; }
    startX = e.touches[0].clientX;
    startY = e.touches[0].clientY;
    deltaX = 0;
    mode = 'undecided';
    card.style.transition = 'none';
  }, {passive: true});

  wrap.addEventListener('touchmove', e => {
    if(e.touches.length !== 1) return;
    if(mode !== 'undecided' && mode !== 'swiping') return;
    const dx = e.touches[0].clientX - startX;
    const dy = e.touches[0].clientY - startY;
    if(mode === 'undecided') {
      if(hasSelection()) { mode = 'selecting'; return; }
      if(Math.abs(dy) > 10 && Math.abs(dy) > Math.abs(dx)) { mode = 'scrolling'; return; }
      if(Math.abs(dx) > 12) {
        mode = 'swiping';
        window.getSelection()?.removeAllRanges();
        if(scroller) { scroller.style.userSelect = 'none'; scroller.style.webkitUserSelect = 'none'; }
      }
    }
    if(mode !== 'swiping') return;
    deltaX = dx;
    const r = State.review;
    const canGoBack = r && r.history && r.history.length > 0;
    let tx = deltaX > 0 ? (canGoBack ? deltaX : deltaX * 0.15) : deltaX * 0.15;
    card.style.transform = `translateX(${tx}px) rotate(${tx * 0.015}deg)`;
    card.style.opacity = String(Math.max(0.5, 1 - Math.abs(tx) / 500));
  }, {passive: true});

  wrap.addEventListener('touchend', () => {
    if(scroller) { scroller.style.userSelect = ''; scroller.style.webkitUserSelect = ''; }
    if(mode === 'swiping') {
      const r = State.review;
      const canGoBack = r && r.history && r.history.length > 0;
      if(deltaX > 80 && canGoBack) {
        mode = 'animating';
        card.style.transition = 'transform 0.25s ease-out, opacity 0.25s ease-out';
        card.style.transform = `translateX(${window.innerWidth + 100}px) rotate(12deg)`;
        card.style.opacity = '0';
        setTimeout(() => { haptic('medium'); undoRev(); }, 200);
      } else {
        card.style.transition = 'transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.3s ease-out';
        card.style.transform = '';
        card.style.opacity = '';
        setTimeout(() => { card.style.transition = ''; }, 350);
        mode = 'idle';
      }
    } else { mode = 'idle'; }
    deltaX = 0;
  });
}

const debouncedSave = (() => {
  let t; const c = W.cancelIdleCallback || clearTimeout, r = W.requestIdleCallback || (cb=>setTimeout(cb,2000));
  return () => { c(t); t = r(saveData); };
})();

W.MathJax = { tex:{inlineMath:[['$','$'],['\\(','\\)']], displayMath:[['$$','$$'],['\\[','\\]']], processEscapes:!0}, options:{skipHtmlTags:['script','style','textarea']}, startup:{typeset:!1} };

const formatText = t => t ? t
    .replace(/(?:>>>|>>)?\s*\[IMAGE_ID:\s*(.+?)\](?:\s*<<<)?/g, (_,f) => `<img src="images/${f.trim()}" alt="Sch√©ma" loading="lazy">`)
    .replace(/\\\[\s*\\text\s*\{([^{}]+)\}\s*\\\]/g, (m,c) => c.includes(' ') ? c : m)
    .replace(/\n|\\newline/g, '<br>').replace(/\[latex\]|\[\/latex\]/g, '').replace(/\[\$\]/g, '\\(').replace(/\[\/\$\]/g, '\\)') : '';

const parsePhysicsData = (rawData) => {
    if (!rawData) return [];
    const decks = rawData.split(/={10,}\s*DECK\s*:\s*/), result = []; let idCounter = 0;
    for(const deckBlock of decks) {
        if (!deckBlock.trim()) continue;
        const lines = deckBlock.split('\n'), deckCode = lines[0].trim(), deckName = typeof PHY_MAP !== 'undefined' && PHY_MAP[deckCode] ? PHY_MAP[deckCode].title : deckCode;
        for(const rawCard of deckBlock.substring(deckCode.length).replace(/^=+/gm, '').trim().split(/-{10,}/)) {
            if (!rawCard.trim()) continue;
            const qMatch = rawCard.match(/Q:\s*([\s\S]*?)(?=R:)/), rMatch = rawCard.match(/R:\s*([\s\S]*)/);
            if (qMatch && rMatch) result.push({ id: 'phy-' + (idCounter++), front: formatText(qMatch[1].trim()), back: formatText(rMatch[1].trim()), chapter: deckName });
        }
    }
    return result;
};

/* --- LIGHTBOX --- */
const LB = { el:null, stage:null, cnv:null, img:null, cnt:null, imgs:[], idx:0, bw:0, bh:0, s:1, mnS:1, mxS:5, x:0, y:0, ptrs:new Map(), sDist:0, sS:1, sX:0, sY:0, psX:0, psY:0, tm:!1 };
function ensureLB(){
  if(LB.el)return LB.el; const el=D.createElement('div'); el.className='img-lightbox'; el.innerHTML='<div class="img-stage" id="lbStg" tabindex="-1"><div class="img-canvas" id="lbCnv"><img id="lbImg" alt=""></div></div><div class="img-counter" id="lbCnt">1/1</div>'; D.body.appendChild(el);
  LB.el=el; LB.stage=el.querySelector('#lbStg'); LB.cnv=el.querySelector('#lbCnv'); LB.img=el.querySelector('#lbImg'); LB.cnt=el.querySelector('#lbCnt');
  const pd=e=>{ LB.stage.setPointerCapture?.(e.pointerId); LB.ptrs.set(e.pointerId,{x:e.clientX,y:e.clientY}); if(LB.ptrs.size===1){LB.psX=LB.x;LB.psY=LB.y;LB.sX=e.clientX;LB.sY=e.clientY;LB.sS=LB.s;LB.tm=!1}else if(LB.ptrs.size===2){const p=[...LB.ptrs.values()];LB.sDist=M.hypot(p[0].x-p[1].x,p[0].y-p[1].y)||1;LB.sS=LB.s;LB.tm=!0} e.preventDefault() };
  const pm=e=>{ if(!LB.ptrs.has(e.pointerId))return; LB.ptrs.set(e.pointerId,{x:e.clientX,y:e.clientY}); const dx=e.clientX-LB.sX, dy=e.clientY-LB.sY; if(M.abs(dx)>6||M.abs(dy)>6)LB.tm=!0; if(LB.ptrs.size>=2){const p=[...LB.ptrs.values()];setLBScale(LB.sS*(M.hypot(p[0].x-p[1].x,p[0].y-p[1].y)/LB.sDist||1))}else setLBPan(LB.psX+dx,LB.psY+dy); e.preventDefault() };
  const pu=e=>{ if(LB.ptrs.has(e.pointerId))LB.ptrs.delete(e.pointerId); if(LB.ptrs.size===0){if(!LB.tm){const r=LB.img.getBoundingClientRect();if(!(e.clientX>=r.left&&e.clientX<=r.right&&e.clientY>=r.top&&e.clientY<=r.bottom))closeLB()}LB.sDist=0}else if(LB.ptrs.size===1){const p=[...LB.ptrs.values()][0];LB.sX=p.x;LB.sY=p.y;LB.psX=LB.x;LB.psY=LB.y;LB.sS=LB.s;LB.sDist=0} };
  let lt=0; LB.stage.addEventListener('pointerdown',e=>{pd(e);const n=Date.now();if(n-lt<250){setLBScale(LB.s>LB.mnS+0.001?LB.mnS:M.min(LB.mxS,LB.mnS*2.2));LB.tm=!0}lt=n});
  LB.stage.addEventListener('pointermove',pm); LB.stage.addEventListener('pointerup',pu); LB.stage.addEventListener('pointercancel',pu); LB.stage.addEventListener('lostpointercapture',pu);
  LB.stage.addEventListener('wheel',e=>{e.preventDefault();setLBScale(LB.s+(e.deltaY>0?-.15:.15)*LB.s)},{passive:!1}); W.addEventListener('resize',()=>{if(LB.el.classList.contains('open'))refitLB()}); return el;
}
function openLB(img,sc){ ensureLB(); const l=[...sc.querySelectorAll('img')]; LB.imgs=l.map(i=>({src:i.currentSrc||i.src,alt:i.alt||'',w:i.naturalWidth||800,h:i.naturalHeight||600})); LB.idx=M.max(0,l.indexOf(img)); LB.el.classList.add('open'); D.body.dataset._ov=D.body.style.overflow||''; D.body.style.overflow='hidden'; LB.el.focus?.(); showLB(LB.idx,!0) }
function closeLB(){ LB.el.classList.remove('open'); LB.imgs=[]; LB.idx=0; D.body.style.overflow=D.body.dataset._ov||'' }
function safeCloseLB(){ try{if(LB?.el?.classList.contains('open'))closeLB()}catch(e){} }
function showLB(i,init=!1){ if(!LB.imgs.length)return; LB.idx=(i+LB.imgs.length)%LB.imgs.length; const t=LB.imgs[LB.idx]; LB.img.src=t.src; LB.img.alt=t.alt; LB.bw=t.w; LB.bh=t.h; if(LB.cnt)LB.cnt.textContent=`${LB.idx+1}/${LB.imgs.length}`; refitLB(init) }
function refitLB(init=!1){ const sw=LB.stage.clientWidth, sh=LB.stage.clientHeight, fit=M.min(sw/LB.bw,sh/LB.bh); LB.mnS=fit; if(init){LB.s=fit;LB.x=(sw-LB.s*LB.bw)/2;LB.y=(sh-LB.s*LB.bh)/2;applyLB()}else setLBScale(fit,!0) }
function applyLB(){ const sw=LB.stage.clientWidth, sh=LB.stage.clientHeight, w=LB.s*LB.bw, h=LB.s*LB.bh; LB.x=w<=sw?(sw-w)/2:clamp(LB.x,sw-w,0); LB.y=h<=sh?(sh-h)/2:clamp(LB.y,sh-h,0); LB.cnv.style.width=LB.bw+'px'; LB.cnv.style.height=LB.bh+'px'; LB.cnv.style.transform=`translate(${LB.x}px,${LB.y}px) scale(${LB.s})` }
function setLBPan(nx,ny){ LB.x=nx; LB.y=ny; applyLB() }
function setLBScale(ns,f=!1){ const os=LB.s, s=clamp(ns,LB.mnS,LB.mxS); if(!f&&M.abs(s-os)<1e-4)return; const cx=LB.stage.clientWidth/2, cy=LB.stage.clientHeight/2; LB.s=s; LB.x=cx-s*((cx-LB.x)/os); LB.y=cy-s*((cy-LB.y)/os); applyLB() }

/* --- DATA LOADING --- */
const parseRaw = r => r.split(/\r?\n/).map(l=>{ const p=l.split('|'); return p.length!==4 ? null : {id:p[0].trim(),front:p[1].trim(),back:p[2].trim(),chapter:p[3].trim()} }).filter(Boolean);

const dataEN = (typeof RAW_EN !== 'undefined') ? parseRaw(RAW_EN) : [];
const dataPHY = (typeof RAW_PHY !== 'undefined') ? parsePhysicsData(RAW_PHY) : [];

let dataMATH = [];

const Media = {
  db: null, cache: new Map(),
  async open(){ if(this.db)return this.db; this.db=await new Promise((s,j)=>{const r=indexedDB.open('flash9x16_media',1);r.onupgradeneeded=()=>{if(!r.result.objectStoreNames.contains('files'))r.result.createObjectStore('files',{keyPath:'key'})};r.onsuccess=()=>s(r.result);r.onerror=()=>j(r.error)}); return this.db },
  async save(k,b,m={}){ const d=await this.open(), tx=d.transaction('files','readwrite'); tx.objectStore('files').put({key:k,blob:b,meta:m,ts:Date.now()}); data.mediaIndex=data.mediaIndex||{}; data.mediaIndex[k]={name:m.name||k,type:b.type,size:b.size}; saveData() },
  async urlFor(k){ if(this.cache.has(k))return this.cache.get(k); const d=await this.open(); return new Promise((s,j)=>{const r=d.transaction('files','readonly').objectStore('files').get(k);r.onsuccess=()=>{if(!r.result?.blob)return j('Missing');const u=URL.createObjectURL(r.result.blob);this.cache.set(k,u);s(u)};r.onerror=()=>j(r.error)}) },
  revokeAll(){ for(const u of this.cache.values())URL.revokeObjectURL(u); this.cache.clear() },
  async clearAll(){ const d=await this.open(), tx=d.transaction('files','readwrite'); tx.objectStore('files').clear(); this.revokeAll(); data.mediaIndex={}; saveData() },
  rwHTML(h,m){ return String(h||'').replace(/(<img\b[^>]?\bsrc=["'])([^"']+)(["'][^>]*>)/gi,(x,p,src,s)=>{const k=m[src.replace(/^.*[\\\/]/,'').replace(/^_+/,'')]||null;return k?`${p}media://${k}${s}`:x}) },
  async resolve(el){ const i=[...el.querySelectorAll('img[src^="media://"]')]; await Promise.all(i.map(async x=>{try{x.src=await Media.urlFor(x.getAttribute('src').replace(/^media:\/\//,''))}catch{}})) }
};
const ensureSQL = (()=>{ let p; return ()=>{ if(!p)p=initSqlJs({locateFile:f=>`https://cdn.jsdelivr.net/npm/sql.js@1.10.2/dist/${f}`}); return p } })();

async function importFiles(fs){ for(const f of fs){ const n=f.name.toLowerCase(); if(n.endsWith('.apkg')) await impApkg(f); else if(n.endsWith('.csv')||n.endsWith('.tsv')) await impDelim(f); else if(n.endsWith('.json')) await impJSON(f) } }

async function impApkg(f){
  try {
    if(!window.JSZip) {
      await new Promise((res, rej) => { const s=D.createElement('script'); s.src='https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js'; s.onload=res; s.onerror=()=>rej(new Error("JSZip load failed")); D.head.appendChild(s); });
    }
    const b = await f.arrayBuffer();
    let z; try { z = await JSZip.loadAsync(b); } catch(e) { throw new Error("Not a valid ZIP/APKG."); }
    let mm = {}; const me = z.file(/^media(\.json)?$/i)[0];
    if(me) { try { mm = JSON.parse(await me.async('string')); } catch(e) {} }
    const iId = `apkg-${slugify(f.name.replace(/\.[^.]+$/,''))}-${Date.now()}`;
    const mnk = {};
    for(const [ns,rn] of Object.entries(mm)){ const e = z.file(new RegExp(`^${ns}$`))[0]; if(!e) continue; const k = `${iId}/${rn||ns}`; await Media.save(k, await e.async('blob'), {name:rn||ns}); mnk[rn] = k; mnk[ns] = k; }
    let col = z.file("collection.anki2") || z.file(/collection\.anki2(1|\.db)?/i)[0];
    if(!col) throw new Error("Anki data not found.");
    const dbData = new Uint8Array(await col.async('uint8array'));
    const SQL = await ensureSQL();
    let db; try { db = new SQL.Database(dbData); } catch(sqlErr) { throw new Error("DB corrupted."); }
    let dk = {}; try { const r = db.exec('select decks from col limit 1'); if(r[0]?.values[0]) dk = JSON.parse(r[0].values[0][0]||'{}'); } catch(e) {}
    let rows; try { rows = db.exec('select cards.id, cards.nid, cards.did, cards.ord, notes.flds from cards join notes on notes.id=cards.nid'); } catch(e) { db.close(); throw new Error("Read error."); }
    if(!rows || !rows[0]) { db.close(); throw new Error("Empty Anki deck."); }
    const byD = new Map(), cols = rows[0].columns, vals = rows[0].values;
    for(const r of vals){ const row = Object.fromEntries(cols.map((c,i) => [c,r[i]])); const dn = (dk[row.did]?.name || `Deck ${row.did}`).replace(/::/g,' ‚Ä∫ '); const fl = (row.flds||'').split('\x1f'); let frontVal = fl[0] || 'Vide'; let backVal = fl[1] || ''; if (row.ord == 1 && fl.length >= 2) { frontVal = fl[1]; backVal = fl[0]; } if (fl.length > 2) { backVal += '<br><br>' + fl.slice(2).join('<br>'); } const ca = byD.get(dn) || []; ca.push({ id: String(row.id), front: Media.rwHTML(frontVal, mnk), back: Media.rwHTML(backVal, mnk) }); byD.set(dn, ca); }
    db.close();
    const chs = []; for(const [n,arr] of byD){ const cds=arr.map(r=>mkCard(`${slugify(n)}-${r.id}`,r.front,r.back)); chs.push(mkChapter('chap-'+slugify(n),n,cds,!0)); }
    const sj = { id: `import-${slugify(f.name)}`, title: f.name.replace(/\.[^.]+$/,''), chapters: chs, imported: !0 }; data.subjects.push(sj); data.app.currentSubjectId = sj.id; saveData();
    toast('Import Anki r√©ussi !', 'success');
  } catch(e) { alert("Erreur import Anki : " + e.message); console.error(e); }
}

async function impDelim(f){ const t=await f.text(), sep=t.includes('\t')?'\t':(t.includes(';')?';':','), l=t.split(/\r?\n/).filter(Boolean); let h=l[0].split(sep).map(s=>s.trim().toLowerCase()), st=0; if(!h.includes('front')) h=['front','back','chapter']; else st=1; const recs=[]; for(let i=st;i<l.length;i++){ const c=l[i].split(sep), r=Object.fromEntries(h.map((x,j)=>[x,c[j]||''])); recs.push({front:r.front||c[0]||'',back:r.back||c[1]||'',chapter:r.chapter||'G√©n√©ral'}) } await impSimpSub(f.name.replace(/\.[^.]+$/,''),recs) }
async function impJSON(f){ const o=JSON.parse(await f.text()); if(Array.isArray(o)) impSimpSub(f.name.replace(/\.[^.]+$/,''),o); else if(o.cards) impSimpSub(o.subject||f.name,o.cards) }
async function impSimpSub(n,l){
  const by={}; l.forEach(x=>{ const c=(x.chapter||'G√©n√©ral').trim()||'G√©n√©ral'; (by[c]=by[c]||[]).push({front:Media.rwHTML(String(x.front||''),{}),back:Media.rwHTML(String(x.back||''),{})}) });
  const chs=Object.entries(by).map(([cn,arr])=>{
    const cds=arr.map((r,i)=>mkCard(`${slugify(cn)}-${i}-${Date.now()}`,r.front,r.back));
    return mkChapter('chap-'+slugify(cn),cn,cds,!0)
  });
  const s={id:`import-${slugify(n)}-${Date.now()}`,title:n,chapters:chs,imported:!0}; data.subjects.push(s); data.app.currentSubjectId=s.id; saveData(); goDeck(!1)
}

let data;
const ChartHit={};
function buildChs(l){ 
  const by={}; l.forEach(r=>{ const n=r.chapter||'Sans cat√©gorie'; (by[n]=by[n]||[]).push(r) }); 
  const orderMap = {};
  [typeof PHY_MAP!=='undefined'&&PHY_MAP, typeof MATH_MAP!=='undefined'&&MATH_MAP].filter(Boolean).forEach(m => Object.values(m).forEach((v,i) => orderMap[v.title] = i));
  const sortedKeys = Object.keys(by);
  sortedKeys.sort((a, b) => { const idxA = orderMap[a] !== undefined ? orderMap[a] : 999; const idxB = orderMap[b] !== undefined ? orderMap[b] : 999; return idxA - idxB; });
  return {
      chapters: sortedKeys.map(n=>{ 
          const cds=by[n].map(r=>mkCard(`${slugify(n)}-${r.id}`,r.front,r.back,r.mathSimple||null));
          return mkChapter('chap-'+slugify(n),n,cds)
      }), 
      app:{currentChapterId:null,theme:'dark',prefs:{fsTerm:22,fsDef:24,accent:'indigo',radius:14}}
  };
}
const buildSub=(t,l) => ({id:slugify(t),title:t,chapters:buildChs(l).chapters,groups:[]});
const buildMathSub = () => {
    const s = buildSub('Maths', dataMATH);
    s.emoji = '';
    if (s.chapters.length >= 1) {
        s.groups = [{
            id: 'g-math-all',
            chapIds: s.chapters.map(c => c.id),
            childGroupIds: [],
            parentGroupId: null,
            createdAt: Date.now(),
            title: 'R√©sum√© de Cours',
            emoji: 'üìñ',
            lastUsed: Date.now()
        }];
    }
    return s;
};
const buildCanon = () => [buildSub('Physique',dataPHY), buildMathSub(), buildSub('Anglais',dataEN)];

function loadData(){ try{const r=LS.getItem(KEY);if(r){const p=JSON.parse(r);if(p.subjects)return p;if(p.chapters)return{subjects:[{id:'anglais',title:'Anglais',chapters:p.chapters,groups:[]}],app:p.app||{theme:'light',currentSubjectId:'anglais'}}}}catch{} const s=buildCanon(); return{subjects:s,app:{currentSubjectId:s[0]?.id,theme:'light',prefs:{fsTerm:22,fsDef:24,accent:'indigo',radius:14}}} }
function saveData(){ try{LS.setItem(KEY,JSON.stringify(data))}catch{} }

function pruneStats(){ const c=new Date(); c.setDate(c.getDate()-180); const k=dateKey(c); for(const s of data.subjects) for(const ch of s.chapters){ for(const x of ['dailyReviews','dailyDurMs','dailyDurCount','dailyChanges','dailyLog']){ const m=ch.stats[x]; if(m) for(const d in m) if(d<k) delete m[d]; } if(ch.stats.dailyLog) for(const a of Object.values(ch.stats.dailyLog)) if(a.length>200) a.splice(0,a.length-200); } }
const getSub = () => data.subjects.find(x=>x.id===data.app.currentSubjectId)||data.subjects[0];
const setSub = id => { if(data.subjects.find(s=>s.id===id)){data.app.currentSubjectId=id;saveData()} };
const getChs = () => getSub()?.chapters||[];
const updChDesc = c => { const e = c.emoji || getEmoji(c.title) || ''; c.description = (e ? e + ' ' : '') + c.title; };
function uniqId(s,b){ const ids=new Set((s.chapters||[]).map(c=>c.id)); if(!ids.has(b))return b; let i=2,d=b; while(ids.has(d))d=b+'-'+i++; return d }
function moveCh(fi,ci,ti){if(fi===ti)return!1;const f=data.subjects.find(s=>s.id===fi),t=data.subjects.find(s=>s.id===ti);if(!f||!t)return!1;const i=f.chapters.findIndex(c=>c.id===ci);if(i<0)return!1;const ch=f.chapters[i];ensGrps(f).forEach(g=>g.chapIds=g.chapIds.filter(id=>id!==ci));valGrps(f);f.chapters.splice(i,1);ch.id=uniqId(t,ch.id);(t.chapters=t.chapters||[]).push(ch);valGrps(t);if(!f.chapters.length){data.subjects=data.subjects.filter(s=>s.id!==f.id);if(data.app.currentSubjectId===fi)data.app.currentSubjectId=data.subjects[0]?.id}saveData();return!0}
function renSub(id,t,e){ const s=data.subjects.find(x=>x.id===id); if(!s)return!1; if(t)s.title=t.trim(); s.emoji=(e||'').trim(); saveData(); return!0 }
const ensGrps=s=>{if(!Array.isArray(s.groups))s.groups=[];return s.groups},findGrp=(s,id)=>ensGrps(s).find(g=>g.id===id),findGrpCh=(s,cid)=>ensGrps(s).find(g=>g.chapIds.includes(cid)),findGrpOfGrp=(s,gid)=>ensGrps(s).find(g=>(g.childGroupIds||[]).includes(gid)),grpEmojis=(s,g)=>{const z=new Set();g.chapIds.forEach(id=>{const c=s.chapters.find(x=>x.id===id),e=c?(c.emoji||getEmoji(c.title)||''):'';if(e)z.add(e)});return[...z].join(', ')};
const valGrps=s=>{const a=new Set(s.chapters.map(c=>c.id)),gi=new Set(ensGrps(s).map(g=>g.id));s.groups=ensGrps(s).map(g=>({...g,chapIds:(g.chapIds||[]).filter(x=>a.has(x)),childGroupIds:(g.childGroupIds||[]).filter(c=>gi.has(c)),parentGroupId:g.parentGroupId||null})).filter(g=>g.chapIds.length>=1||(g.childGroupIds||[]).length>=1)};
function getAllChapIdsRecursive(s,gid){const g=findGrp(s,gid);if(!g)return[];let ids=[...g.chapIds];for(const c of(g.childGroupIds||[]))ids.push(...getAllChapIdsRecursive(s,c));return[...new Set(ids)]}

function buildGrpStats(s,g){const ids=getAllChapIdsRecursive(s,g.id),chs=ids.map(id=>s.chapters.find(c=>c.id===id)).filter(Boolean),c=GRADE_INIT();chs.forEach(ch=>{const k=getLive(ch);for(let x in c)c[x]+=k[x]});const st={totalReviews:chs.reduce((a,b)=>a+(b.stats.totalReviews||0),0),dailyReviews:{},dailyDurMs:{},dailyDurCount:{},dailyChanges:{}},b=new Date();for(let i=0;i<60;i++){const d=new Date(b);d.setDate(b.getDate()-i);const k=dateKey(d);st.dailyReviews[k]=chs.reduce((a,b)=>a+(b.stats.dailyReviews[k]||0),0);st.dailyDurMs[k]=chs.reduce((a,b)=>a+(b.stats.dailyDurMs[k]||0),0);st.dailyDurCount[k]=chs.reduce((a,b)=>a+(b.stats.dailyDurCount[k]||0),0);st.dailyChanges[k]=chs.reduce((a,ch)=>{const v=ch.stats.dailyChanges[k];if(v){a.changed+=v.changed||0;a.total+=v.total||0}return a},{changed:0,total:0})}return{counts:c,stats:st}}
function buildVirt(s,g){
  const allIds = getAllChapIdsRecursive(s, g.id);
  const chs=allIds.map(id=>s.chapters.find(c=>c.id===id)).filter(Boolean), cards=[];
  chs.forEach(ch=>ch.cards.forEach(c=>cards.push({...c,id:`virt-${ch.id}-${c.id}`,_origin:{chapId:ch.id,cardId:c.id}})));
  const gs = buildGrpStats(s,g);
  return {id:'group-'+g.id,_groupId:g.id,title:g.title||`Fichier (${grpEmojis(s,g)})`,emoji:g.emoji||'',description:(g.emoji?g.emoji+' ':'')+(g.title||'Fichier'),virtual:!0,_ids:allIds,settings:{sessionSize:10,dailyGoal:10,reviewOrder:'front-first',langSwap:!1},filters:g.filters?deepClone(g.filters):{grades:GRADE_FILTERS()},stats:{gradeCounts:gs.counts,...gs.stats},cards,deadline:g.deadline,lastUsed:g.lastUsed}
}
function addGrp(s,ids,p=null){const u=[...new Set(ids)].filter(Boolean);if(u.length<2)return null;const gid='g'+Date.now().toString(36);ensGrps(s).push({id:gid,chapIds:u,childGroupIds:[],parentGroupId:p||null,createdAt:Date.now(),title:'',emoji:'',lastUsed:Date.now()});if(p){const pg=findGrp(s,p);if(pg){if(!pg.childGroupIds)pg.childGroupIds=[];pg.childGroupIds.push(gid);pg.chapIds=pg.chapIds.filter(id=>!u.includes(id))}}return gid}
function toGrp(s,g,c){const x=findGrp(s,g);if(x&&!x.chapIds.includes(c))x.chapIds.push(c)}
function remFromGrp(s,g,c){const x=findGrp(s,g);if(x)x.chapIds=x.chapIds.filter(i=>i!==c)}
function delGrp(s,gid){const g=findGrp(s,gid);if(!g)return;const p=g.parentGroupId?findGrp(s,g.parentGroupId):null;if(p){g.chapIds.forEach(c=>{if(!p.chapIds.includes(c))p.chapIds.push(c)});(g.childGroupIds||[]).forEach(cg=>{const x=findGrp(s,cg);if(x){x.parentGroupId=g.parentGroupId;if(!p.childGroupIds)p.childGroupIds=[];p.childGroupIds.push(cg)}});p.childGroupIds=(p.childGroupIds||[]).filter(x=>x!==gid)}else(g.childGroupIds||[]).forEach(cg=>{const x=findGrp(s,cg);if(x)x.parentGroupId=null});s.groups=ensGrps(s).filter(x=>x.id!==gid)}
function removeChildGrpFromParent(s,pid,cid){const p=findGrp(s,pid);if(!p)return;p.childGroupIds=(p.childGroupIds||[]).filter(x=>x!==cid);const c=findGrp(s,cid);if(c){c.chapIds.forEach(id=>{if(!p.chapIds.includes(id))p.chapIds.push(id)});c.parentGroupId=null}}

let selectionMode = false;
let selectedIds = new Set(); 
let expandedFolders = new Set(); 
let selectionContext = null; 

function goDeckKeepScroll() {
  const scrollEl = $('#dL');
  const savedScroll = scrollEl ? scrollEl.scrollTop : 0;
  goDeck(false);
  requestAnimationFrame(() => {
    const newScrollEl = $('#dL');
    if(newScrollEl) newScrollEl.scrollTop = savedScroll;
  });
}

function enterSelectionMode(initialId) {
  selectionMode = true;
  selectedIds = new Set();
  if(initialId) selectedIds.add(initialId);
  removeFABs();
  goDeckKeepScroll();
}

function exitSelectionMode() {
  selectionMode = false;
  selectedIds.clear();
  removeFABs();
  goDeckKeepScroll();
}

function removeFABs() {
  $$('.fab-confirm, .fab-cancel').forEach(el => el.remove());
}

function renderFABs() {
  removeFABs();
  if(!selectionMode) return;
  
  const fabConfirm = D.createElement('button');
  fabConfirm.className = 'fab-confirm';
  fabConfirm.innerHTML = '‚úì';
  fabConfirm.title = 'Cr√©er un dossier';
  fabConfirm.onclick = () => {
    const ids = [...selectedIds];
    if(ids.length < 2) { toast('S√©lectionnez au moins 2 √©l√©ments', 'error'); return; }
    const sub = getSub();
    let parentGid = null;
    for(const eid of expandedFolders) {
      const g = findGrp(sub, eid);
      if(g) {
        const allInFolder = ids.every(id => g.chapIds.includes(id));
        if(allInFolder) { parentGid = eid; break; }
      }
    }
    const newGid = addGrp(sub, ids, parentGid);
    if(newGid) {
      const title = prompt('Nom du dossier:', '');
      if(title) { const ng = findGrp(sub, newGid); if(ng) ng.title = title.trim(); }
      valGrps(sub); saveData();
      toast('Dossier cr√©√© !', 'success');
    }
    exitSelectionMode();
  };
  D.body.appendChild(fabConfirm);
  
  const fabCancel = D.createElement('button');
  fabCancel.className = 'fab-cancel';
  fabCancel.innerHTML = '‚úï';
  fabCancel.title = 'Annuler';
  fabCancel.onclick = () => exitSelectionMode();
  D.body.appendChild(fabCancel);
}

const Nav = {
  stack: [], scrollPos: 0,
  push(){ this.scrollPos = $('#dL')?.scrollTop||0; this.stack.push(deepClone({view:State.view,chapterId:State.chapterId,review:State.review,dailyKey:State.dailyKey,scrollPos:this.scrollPos,expandedFolders:[...expandedFolders]})) },
  back(){ 
    if(!this.stack.length) return false; 
    const p=this.stack.pop(); 
    State.virtualChapter=null; 
    State.view=p.view; State.chapterId=p.chapterId; State.review=p.review; State.dailyKey=p.dailyKey; 
    expandedFolders = new Set(p.expandedFolders || []);
    this.scrollPos = p.scrollPos || 0; 
    render(!1);
    return true;
  },
  clear(){ this.stack=[]; this.scrollPos=0 }
};

const State = { view:'deck', chapterId:null, review:null, cardsIndex:0, dailyKey:null, virtualChapter:null };
const _real = id => getChs().find(c=>c.id===id), getCh = id => (State.virtualChapter?.id===id) ? State.virtualChapter : _real(id);
function updFilt(ch,key){ let t=ch; if(ch.virtual&&ch._groupId){const g=findGrp(getSub(),ch._groupId);if(g){if(!g.filters)g.filters={grades:GRADE_FILTERS()};t=g}} togFilt(t,key); if(t!==ch)ch.filters=t.filters; saveData(); goChapter(ch.id,!1) }
const delImpCh = id => { const s=getSub(), i=s.chapters.findIndex(c=>c.id===id); if(i<0||!s.chapters[i].imported||!confirm('Supprimer ?'))return!1; ensGrps(s).forEach(g=>g.chapIds=g.chapIds.filter(x=>x!==id)); valGrps(s); s.chapters.splice(i,1); if(!s.chapters.length&&s.imported){data.subjects=data.subjects.filter(x=>x.id!==s.id);data.app.currentSubjectId=data.subjects[0]?.id} saveData(); return!0 };

/* --- DEADLINE & LOGIC --- */
function getDeckTint(item, type) {
    let k; if (type === 'chapter') k = item.stats.gradeCounts || getLive(item); else k = buildGrpStats(getSub(), item).counts;
    const totalGraded = k.echec + k.difficile + k.bien + k.facile;
    let r = 0, g = 0, b = 0, a = 0;
    if (totalGraded > 0) {
        const wRed = (k.echec + k.difficile) / totalGraded, wBlue = k.bien / totalGraded, wGreen = k.facile / totalGraded;
        r = (239 * wRed) + (59 * wBlue) + (34 * wGreen); g = (68 * wRed) + (130 * wBlue) + (197 * wGreen); b = (68 * wRed) + (246 * wBlue) + (94 * wGreen); a = 0.25;
    }
    if (item.deadline) {
        const now = new Date(); now.setHours(0,0,0,0); const ddl = new Date(item.deadline); ddl.setHours(0,0,0,0);
        const diff = (ddl - now) / 864e5; let urgency = 0;
        if (diff <= 0) urgency = 1; else if (diff <= 7) urgency = 1 - (diff / 7);
        if (urgency > 0) { const tR = 239, tG = 68, tB = 68; if (totalGraded === 0) { r = tR; g = tG; b = tB; a = 0.5 * urgency; } else { r = r * (1 - urgency) + tR * urgency; g = g * (1 - urgency) + tG * urgency; b = b * (1 - urgency) + tB * urgency; a = 0.25 + (0.25 * urgency); } }
    }
    if (a <= 0.01) return '';
    return `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${a})`;
}

function checkExpiredDates(list) {
    const now = new Date(); now.setHours(0,0,0,0); let changed = false;
    list.forEach(item => { if (item.deadline) { const ddl = new Date(item.deadline); ddl.setHours(0,0,0,0); if (ddl < now) { item.deadline = null; changed = true; } } });
    return changed;
}

function getDailyGoalCalc(ch) {
    if(!ch.deadline) return null;
    const now = new Date(); now.setHours(0,0,0,0); const ddl = new Date(ch.deadline); ddl.setHours(0,0,0,0);
    let days = Math.ceil((ddl - now) / 864e5); if (days <= 0) days = 1;
    const k = ch.stats.gradeCounts || getLive(ch);
    let pool = k.unseen + k.echec + k.difficile, label = "cartes (Mauvaises)";
    if (pool === 0) { pool = k.bien; label = "cartes (Bien)"; if (pool === 0) return { val: 0, text: "Objectif atteint !", pool: 0 }; }
    return { val: Math.ceil(pool / days), text: `${label} / jour`, pool: pool };
}

/* --- NAVIGATION & UI --- */
const backBtn=$('#backBtn'), titleEl=$('#title'), botAct=$('#bottomActions'), revBar=$('#revisionBar'), startBtn=$('#startReviewBtn');

function renSubMenu(){
  let m=$('#subjectMenu'); if(!m){m=D.createElement('div');m.id='subjectMenu';m.className='subject-menu';D.body.appendChild(m)}
  m.innerHTML=data.subjects.map(s=>`<div class="subject-item" data-id="${s.id}"><div class="name">${s.emoji?s.emoji+' ':''}${s.title}</div><div class="meta">${s.chapters?.length||0} chap.</div>${s.id===data.app.currentSubjectId?'<div class="muted">‚úì</div>':''}<div class="subject-actions"><button class="btn btn--tiny rs">‚úèÔ∏è</button>${!(s.chapters?.length)?'<button class="btn btn--tiny ds">üóëÔ∏è</button>':''}</div></div>`).join('');
  $$('.subject-item',m).forEach(el=>{
    el.onclick=e=>{if(e.target.closest('button'))return;const id=el.dataset.id;if(id!==data.app.currentSubjectId){setSub(id);closeSubMenu();goDeck(!1)}else closeSubMenu();e.stopPropagation()};
    const r=el.querySelector('.rs'); if(r)r.onclick=e=>{e.stopPropagation();const id=el.dataset.id,s=data.subjects.find(x=>x.id===id),t=prompt('Nom:',s.title);if(t){renSub(id,t,prompt('Emoji:',s.emoji));renSubMenu();setTop({title:`Deck ‚Ä¢ ${getSub().title}`});goDeck(!1)}};
    const d=el.querySelector('.ds'); if(d)d.onclick=e=>{e.stopPropagation();const id=el.dataset.id;if(confirm('Supprimer ?')){data.subjects=data.subjects.filter(s=>s.id!==id);if(data.app.currentSubjectId===id)data.app.currentSubjectId=data.subjects[0]?.id;closeSubMenu();goDeck(!1);saveData()}}
  })
}
const openSubMenu = () => { renSubMenu(); const m=$('#subjectMenu'), r=titleEl.getBoundingClientRect(); m.style.top=`${r.bottom+6}px`; m.style.left=`${r.left}px`; m.style.display='block'; setTimeout(()=>D.addEventListener('click',clsOnOut),0) };
const closeSubMenu = () => { const m=$('#subjectMenu'); if(m)m.style.display='none'; D.removeEventListener('click',clsOnOut) };
const clsOnOut = e => { if(!$('#subjectMenu')?.contains(e.target)&&e.target!==titleEl)closeSubMenu() };

titleEl.onclick = () => { if(State.view!=='deck')goDeck(!1); else($('#subjectMenu')?.style.display==='block')?closeSubMenu():openSubMenu() };

backBtn.onclick = () => { 
  if(selectionMode) { exitSelectionMode(); return; }
  if(State.view==='recap'){
    if(Nav.stack.length)Nav.stack.pop();
    const t=State.review?.chapterId||State.chapterId;
    State.review=null; hideRevAct();
    if(t?.startsWith('group-')){
      const g=findGrp(getSub(),t.replace('group-',''));
      if(g){State.virtualChapter=buildVirt(getSub(),g);goChapter(State.virtualChapter.id,!1)}
      else goDeck(!1);
    } else if(t) goChapter(t,!1);
    else goDeck(!1);
  } else if(State.view==='review') {
    if(!State.review?.end && !confirm('Quitter la r√©vision ?')) return;
    if(Nav.stack.length) Nav.back();
    else goDeck(!1);
  } else {
    if(Nav.stack.length) {
      Nav.back();
    } else {
      if(expandedFolders.size > 0) {
        expandedFolders.clear();
        goDeck(false);
      }
    }
  }
};

$('#cardsBtn').onclick = () => goCards(State.chapterId); 
$('#settingsBtn').onclick = () => openSet(State.chapterId); 
startBtn.onclick = () => startRev(State.chapterId);

function setTop({title,showBack}){ backBtn.classList.toggle('hidden',showBack===!1); if(title)titleEl.textContent=title }
function setBot({actions,revision,sz=10,en=true,av=null,cid=null}){ botAct.style.display=actions?'grid':'none'; revBar.style.display=revision?'block':'none'; $('#app').style.setProperty('--row-actions',actions?'52px':'0px'); $('#app').style.setProperty('--row-rev',revision?'64px':'0px'); if(av==null&&cid){const c=getCh(cid);av=c?cntAv(c):0} startBtn.textContent=`R√©vision ‚Ä¢ ${av>0?M.min(sz,av):sz} cartes${revision&&(av>0)?` ‚Ä¢ ${av} dispo`:''}`; startBtn.disabled=!en||(av||0)<=0 }
function render(push=true){ if(State.view==='deck')goDeck(push); else if(State.view==='chapter')goChapter(State.chapterId,push); else if(State.view==='cards')goCards(State.chapterId,push); else if(State.view==='review')goReview(push); else if(State.view==='recap')goRecap(push); else if(State.view==='settings')openSet(State.chapterId,push); else if(State.view==='daily')goDaily(State.chapterId,State.dailyKey,push) }
const hideRevAct = () => { $('#reviewActionsBar').style.display='none' };

function goDeck(push=true){
  safeCloseLB(); Media.revokeAll(); clearMathCache();
  if(push) Nav.push(); State.view='deck'; State.chapterId=null; 
  const s=getSub(); setTop({title:`Deck ‚Ä¢ ${s.emoji?s.emoji+' ':''}${s.title}`, showBack: selectionMode || expandedFolders.size > 0}); setBot({actions:!1, revision:!1}); hideRevAct();
  let needsSave = false; if (checkExpiredDates(ensGrps(s))) needsSave = true; if (checkExpiredDates(s.chapters)) needsSave = true; if (needsSave) debouncedSave();

  const v=$('#view'), grps=ensGrps(s), chs=(s.chapters||[]);
  
  const items = buildDeckItems(s, null, 0);
  
      v.innerHTML=`<div class="card flexcol" style="flex:1"><div class="deck-head" style="display:flex;align-items:center;justify-content:space-between"><div class="section-title" style="margin:0">Chapitres & Fichiers</div><div class="actions" style="display:flex;gap:6px"><button class="btn ${selectionMode?'btn--primary':'btn--ghost'} btn--tiny" id="editModeBtn">${selectionMode?'‚úì Terminer':'‚úèÔ∏è √âditer'}</button><button class="btn btn--ghost btn--tiny" id="impB">Importer</button><input id="impI" type="file" class="hidden" accept="*/*" multiple/></div></div><div id="dL" class="scroll-y" style="flex:1;min-height:0;padding-right:4px"><div class="list" id="deckList"></div></div></div>`;
      const listEl = $('#deckList');
  listEl.innerHTML = items.map(item => renderDeckItem(item, s)).join('');
  const impBtn = $('#impB');
  const impInput = $('#impI');
  if (impBtn && impInput) { impBtn.onclick = () => impInput.click(); }
    $('#impI').onchange = async e => { try { await importFiles([...e.target.files]); toast('Import termin√© !', 'success'); goDeck(!1); } catch(x) { toast('Erreur import', 'error'); } finally { e.target.value=''; } };
  
  $('#editModeBtn').onclick = () => {
  if(selectionMode) {
    exitSelectionMode();
  } else {
    selectionMode = true;
    selectedIds.clear();
    goDeckKeepScroll();
  }
};
  if(!push && Nav.scrollPos > 0) { setTimeout(() => { const list = $('#dL'); if(list) list.scrollTop = Nav.scrollPos; }, 50); }
  const list = $('#dL'); if(list) bindPullRefresh(list, () => { toast('Actualisation...', 'info', 1000); goDeck(false); });
  
  if(selectionMode) renderFABs();
  
  bindDeckNew();
}

function buildDeckItems(s, parentGid, depth) {
  const grps = ensGrps(s);
  const items = [];
  
  const levelGroups = grps.filter(g => (g.parentGroupId||null) === parentGid);
  const inGroupAtLevel = new Set();
  levelGroups.forEach(g => g.chapIds.forEach(id => inGroupAtLevel.add(id)));
  levelGroups.forEach(g => (g.childGroupIds||[]).forEach(cgid => {
    getAllChapIdsRecursive(s, cgid).forEach(id => inGroupAtLevel.add(id));
  }));
  
  let levelChapters;
  if(parentGid === null) {
    const allInGroups = new Set();
    grps.forEach(g => {
      if(!g.parentGroupId) {
        g.chapIds.forEach(id => allInGroups.add(id));
        (g.childGroupIds||[]).forEach(cgid => getAllChapIdsRecursive(s, cgid).forEach(id => allInGroups.add(id)));
      }
    });
    levelChapters = s.chapters.filter(c => !allInGroups.has(c.id));
  } else {
    const parentG = findGrp(s, parentGid);
    levelChapters = parentG ? parentG.chapIds.map(id => s.chapters.find(c=>c.id===id)).filter(Boolean) : [];
  }
  
  const sorter = (a, b) => { 
    const aDeadline = a.deadline || (a.type === 'group' ? null : null);
    const bDeadline = b.deadline || (b.type === 'group' ? null : null);
    if (aDeadline && !bDeadline) return -1; if (!aDeadline && bDeadline) return 1; 
    if (aDeadline && bDeadline) { const diff = new Date(aDeadline) - new Date(bDeadline); if (diff !== 0) return diff; }
    return (b.lastUsed || 0) - (a.lastUsed || 0); 
  };
  
  const groupItems = levelGroups.map(g => ({type:'group', group:g, depth}));
  const chapItems = levelChapters.map(c => ({type:'chapter', chapter:c, depth, parentGid}));
  
  groupItems.sort((a,b) => sorter(a.group, b.group));
  chapItems.sort((a,b) => sorter(a.chapter, b.chapter));
  
  for(const gi of groupItems) {
    items.push(gi);
    if(expandedFolders.has(gi.group.id)) {
      const children = buildDeckItems(s, gi.group.id, depth + 1);
      items.push(...children);
    }
  }
  items.push(...chapItems);
  
  return items;
}

function renderDeckItem(item, s) {
  const depthClass = item.depth > 0 ? ` folder-child${item.depth >= 2 ? ` folder-child-depth-${Math.min(item.depth, 3)}` : ''}` : '';
  
  if(item.type === 'group') {
    const g = item.group;
    const {counts:c} = buildGrpStats(s, g);
    const tot = Object.values(c).reduce((a,b)=>a+b,0);
    const pct = tot ? M.round((tot-c.unseen)*100/tot) : 0;
    const tint = getDeckTint(g, 'group');
    const emoji = g.emoji || 'üìÅ';
    const title = g.title || 'Fichier ('+grpEmojis(s,g)+')';
    const isExpanded = expandedFolders.has(g.id);
    const chevron = isExpanded ? '‚ñæ' : '‚Ä∫';
    
    let rightContent = '';
    if(selectionMode) {
      rightContent = `<button class="remove-x" data-action="delete-folder" data-gid="${g.id}" title="Supprimer le dossier">‚úï</button>`;
    } else if(isExpanded) {
      const parentG = findGrpOfGrp(s, g.id);
      if(parentG) {
        rightContent = `<button class="remove-x" data-action="remove-subfolder" data-gid="${g.id}" data-parent="${parentG.id}" title="Sortir du dossier" style="margin-right:12px">‚úï</button>`;
      }
    }
    
    return `<div class="deck-item${depthClass}" data-type="group" data-id="${g.id}" style="${tint?'background-color:'+tint:''}">
      <div class="slide">
        <div class="deck-emoji">${emoji}</div>
        <div class="deck-info">
          <div class="deck-title">${title}</div>
          <div class="deck-sub">
            <div class="mini-bar"><div class="mini-bar-fill" style="width:${pct}%"></div></div>
            <span>${pct}%</span>
            <div class="mini-dots"><div class="md" style="background:var(--red)"></div><div class="md" style="background:var(--amber)"></div><div class="md" style="background:var(--blue)"></div><div class="md" style="background:var(--green)"></div></div>
            <span>${c.echec}¬∑${c.difficile}¬∑${c.bien}¬∑${c.facile}</span>
            <span class="folder-badge">${getAllChapIdsRecursive(s, g.id).length} chap.</span>
          </div>
        </div>
        ${rightContent}
        <div class="deck-chevron">${chevron}</div>
      </div>
    </div>`;
  } else {
    const c = item.chapter;
    const k = getLive(c), tot = c.cards.length, pct = tot ? M.round((tot-k.unseen)/tot*100) : 0;
    const tint = getDeckTint(c, 'chapter');
    const emoji = c.emoji || getEmoji(c.title) || 'üìÑ';
    
    let rightContent = '';
    if(selectionMode) {
      const isChecked = selectedIds.has(c.id);
      rightContent = `<div class="sel-checkbox ${isChecked ? 'checked' : ''}" data-action="toggle-select" data-cid="${c.id}"></div>`;
    } else if(item.parentGid && expandedFolders.has(item.parentGid)) {
      rightContent = `<button class="remove-x" data-action="remove-from-folder" data-cid="${c.id}" data-gid="${item.parentGid}" title="Sortir du dossier" style="margin-right:12px">‚úï</button>`;
    }
    
    if(selectionMode) {
      rightContent = '';
    }
    let selectBox = '';
    if(selectionMode) {
      const isChecked = selectedIds.has(c.id);
      selectBox = `<div class="sel-checkbox ${isChecked ? 'checked' : ''}" data-action="toggle-select" data-cid="${c.id}"></div>`;
    }
    
    return `<div class="deck-item${depthClass}" data-type="chapter" data-id="${c.id}" data-parent-gid="${item.parentGid||''}" style="${tint?'background-color:'+tint:''}">
      ${c.imported?'<div class="right-action"><button class="btn btn--solid btn--red btn--tiny delCh" data-cid="'+c.id+'">Supprimer</button></div>':''}
      <div class="slide">
        ${selectBox}
        <div class="deck-emoji">${emoji}</div>
        <div class="deck-info">
          <div class="deck-title">${c.title}</div>
          <div class="deck-sub">
            <div class="mini-bar"><div class="mini-bar-fill" style="width:${pct}%"></div></div>
            <span>${pct}%</span>
            <div class="mini-dots"><div class="md" style="background:#9ca3af"></div><div class="md" style="background:var(--red)"></div><div class="md" style="background:var(--green)"></div></div>
            <span>${k.unseen}¬∑${k.echec}¬∑${k.facile}</span>
          </div>
        </div>
        ${rightContent}
        <div class="deck-chevron">‚Ä∫</div>
      </div>
    </div>`;
  }
}

function bindDeckNew() {
  const l = $('#dL'); if(!l) return;
  const sub = getSub();
  
  if(bindDeckNew._globalExit) D.removeEventListener('pointerup', bindDeckNew._globalExit);
  bindDeckNew._globalExit = (e) => {
    if(!selectionMode) return;
       const deckItem = e.target.closest('.deck-item, .fab-confirm, .fab-cancel');
    if(!deckItem) exitSelectionMode();
  };
  D.addEventListener('pointerup', bindDeckNew._globalExit);

  l.onclick = e => {
    if(e.target.matches('.delCh')) { e.stopPropagation(); if(delImpCh(e.target.dataset.cid)) goDeck(!1); return; }
    const selBox = e.target.closest('[data-action="toggle-select"]');
    if(selBox) { e.stopPropagation(); const cid = selBox.dataset.cid; if(selectedIds.has(cid)) selectedIds.delete(cid); else selectedIds.add(cid);
goDeckKeepScroll(); return; }
    const remBtn = e.target.closest('[data-action="remove-from-folder"]');
    if(remBtn) { e.stopPropagation(); remFromGrp(sub, remBtn.dataset.gid, remBtn.dataset.cid); valGrps(sub); saveData(); goDeckKeepScroll(); return; }
    const delFolderBtn = e.target.closest('[data-action="delete-folder"]');
    if(delFolderBtn) { e.stopPropagation(); if(confirm('Supprimer ce dossier ?')) { delGrp(sub, delFolderBtn.dataset.gid); valGrps(sub); saveData(); exitSelectionMode(); } return; }
    const remSubBtn = e.target.closest('[data-action="remove-subfolder"]');
    if(remSubBtn) { e.stopPropagation(); removeChildGrpFromParent(sub, remSubBtn.dataset.parent, remSubBtn.dataset.gid); valGrps(sub); saveData(); goDeckKeepScroll(); return; }
  };
  
  let longPressTimer = null;
  let startX = 0, startY = 0;
  let pressedEl = null;
  let didLongPress = false;
  
  let dragging = false;
  let dragData = null; 
  let dragGhost = null;
  let dragStarted = false;
  let currentDropTarget = null;
  let dropMode = null; 
  
  function createGhost(item) {
    const ghost = D.createElement('div');
    ghost.className = 'drag-ghost';
    const titleEl = item.querySelector('.deck-title');
    const emoji = item.querySelector('.deck-emoji');
    ghost.textContent = (emoji ? emoji.textContent + ' ' : '') + (titleEl ? titleEl.textContent : 'Item');
    D.body.appendChild(ghost);
    return ghost;
  }
  
  function updateGhost(x, y) {
    if(!dragGhost) return;
    dragGhost.style.transform = `translate(${x - 30}px, ${y - 20}px) scale(1.02)`;
  }
  
  function removeGhost() {
    if(dragGhost) { dragGhost.remove(); dragGhost = null; }
  }
  
  function clearDropTargets() {
    $$('.drop-target, .drop-target-above, .drop-target-below, .drop-target-inside', l).forEach(el => {
      el.classList.remove('drop-target', 'drop-target-above', 'drop-target-below', 'drop-target-inside');
    });
    currentDropTarget = null;
    dropMode = null;
  }
  
  function getDropInfo(x, y) {
    const items = $$('.deck-item', l);
    for(const item of items) {
      const rect = item.getBoundingClientRect();
      if(x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) continue;
      
      const itemType = item.dataset.type;
      const itemId = item.dataset.id;
      
      if(dragData && itemId === dragData.id) continue;
      
      const relY = (y - rect.top) / rect.height;
      
      if(itemType === 'group') {
        if(relY < 0.25) return { el: item, type: itemType, id: itemId, mode: 'above' };
        if(relY > 0.75) return { el: item, type: itemType, id: itemId, mode: 'below' };
        return { el: item, type: itemType, id: itemId, mode: 'inside' };
      } else {
        if(relY < 0.5) return { el: item, type: itemType, id: itemId, mode: 'above' };
        return { el: item, type: itemType, id: itemId, mode: 'below' };
      }
    }
    return null;
  }
  
  function executeDrop(dragInfo, dropInfo) {
    if(!dragInfo || !dropInfo) return;
    
    const sub = getSub();
    const srcType = dragInfo.type;
    const srcId = dragInfo.id;
    
    if(dropInfo.mode === 'root') {
      if(srcType === 'chapter') {
        const parentG = findGrpCh(sub, srcId);
        if(parentG) { remFromGrp(sub, parentG.id, srcId); }
      } else if(srcType === 'group') {
        const parentG = findGrpOfGrp(sub, srcId);
        if(parentG) { removeChildGrpFromParent(sub, parentG.id, srcId); }
      }
      valGrps(sub); saveData();
      toast('D√©plac√© √† la racine', 'success');
      return;
    }
    
    const dstType = dropInfo.type;
    const dstId = dropInfo.id;
    
    if(dropInfo.mode === 'inside' && dstType === 'group') {
      if(srcType === 'chapter') {
        const oldG = findGrpCh(sub, srcId);
        if(oldG && oldG.id !== dstId) remFromGrp(sub, oldG.id, srcId);
        toGrp(sub, dstId, srcId);
        toast('Chapitre ajout√© au dossier', 'success');
      } else if(srcType === 'group' && srcId !== dstId) {
        const srcG = findGrp(sub, srcId);
        const dstG = findGrp(sub, dstId);
        if(srcG && dstG) {
          const dstAllChildren = getAllChapIdsRecursive(sub, srcId);
          const isCircular = (function checkCirc(gid) {
            if(gid === srcId) return true;
            const g = findGrp(sub, gid);
            if(!g) return false;
            return (g.childGroupIds||[]).some(cg => checkCirc(cg));
          })(dstId);
          
          if(!isCircular) {
            const oldParent = findGrpOfGrp(sub, srcId);
            if(oldParent) {
              oldParent.childGroupIds = (oldParent.childGroupIds||[]).filter(x => x !== srcId);
            }
            srcG.parentGroupId = dstId;
            if(!dstG.childGroupIds) dstG.childGroupIds = [];
            if(!dstG.childGroupIds.includes(srcId)) dstG.childGroupIds.push(srcId);
            toast('Dossier imbriqu√©', 'success');
          } else {
            toast('Impossible : r√©f√©rence circulaire', 'error');
          }
        }
      }
    } else if(dropInfo.mode === 'above' || dropInfo.mode === 'below') {
      if(srcType === 'chapter') {
        let targetParentG = null;
        if(dstType === 'chapter') {
          targetParentG = findGrpCh(sub, dstId);
        } else if(dstType === 'group') {
          const dstG = findGrp(sub, dstId);
          targetParentG = dstG ? (dstG.parentGroupId ? findGrp(sub, dstG.parentGroupId) : null) : null;
        }
        
        const oldG = findGrpCh(sub, srcId);
        if(oldG) remFromGrp(sub, oldG.id, srcId);
        
        if(targetParentG) {
          toGrp(sub, targetParentG.id, srcId);
          toast('Chapitre d√©plac√©', 'success');
        } else {
          toast('Chapitre d√©plac√© √† la racine', 'success');
        }
      } else if(srcType === 'group') {
        const srcG = findGrp(sub, srcId);
        if(!srcG) return;
        
        let targetParentGid = null;
        if(dstType === 'group') {
          const dstG = findGrp(sub, dstId);
          targetParentGid = dstG ? dstG.parentGroupId : null;
        } else if(dstType === 'chapter') {
          const parentG = findGrpCh(sub, dstId);
          targetParentGid = parentG ? parentG.id : null;
        }
        
        const oldParent = findGrpOfGrp(sub, srcId);
        if(oldParent) {
          oldParent.childGroupIds = (oldParent.childGroupIds||[]).filter(x => x !== srcId);
        }
        
        if(targetParentGid && targetParentGid !== srcId) {
          const newParent = findGrp(sub, targetParentGid);
          if(newParent) {
            srcG.parentGroupId = targetParentGid;
            if(!newParent.childGroupIds) newParent.childGroupIds = [];
            if(!newParent.childGroupIds.includes(srcId)) newParent.childGroupIds.push(srcId);
          } else {
            srcG.parentGroupId = null;
          }
        } else {
          srcG.parentGroupId = null;
        }
        toast('Dossier d√©plac√©', 'success');
      }
    }
    
    valGrps(sub); saveData();
  }
  
  const onPointerDown = e => {
    if(e.target.closest('button, .sel-checkbox, .remove-x')) return;
    const item = e.target.closest('.deck-item');
    if(!item) return;
    
    pressedEl = item;
    startX = e.clientX;
    startY = e.clientY;
    didLongPress = false;
    dragging = false;
    dragStarted = false;
    
    const type = item.dataset.type;
    const id = item.dataset.id;
    
    clearTimeout(longPressTimer);
    
    longPressTimer = setTimeout(() => {
      didLongPress = true;
      haptic('medium');
      
      dragging = true;
      dragData = { type, id, el: item };
      item.classList.add('dragging-origin');
      dragGhost = createGhost(item);
      updateGhost(startX, startY);
      
      l.classList.add('scroll-lock');
    }, 400);
  };
  
  const onPointerMove = e => {
    if(!pressedEl) return;
    const dx = e.clientX - startX, dy = e.clientY - startY;
    
    if(!dragging && M.hypot(dx, dy) > 15) {
      clearTimeout(longPressTimer);
      return;
    }
    
    if(dragging) {
      e.preventDefault();
      dragStarted = true;
      updateGhost(e.clientX, e.clientY);
      
      clearDropTargets();
      const info = getDropInfo(e.clientX, e.clientY);
      if(info) {
        if(info.mode === 'root') {
          info.el.classList.add('drop-target');
        } else if(info.mode === 'inside') {
          info.el.classList.add('drop-target-inside');
        } else if(info.mode === 'above') {
          info.el.classList.add('drop-target-above');
        } else if(info.mode === 'below') {
          info.el.classList.add('drop-target-below');
        }
        currentDropTarget = info;
        dropMode = info.mode;
      }
      
      const lRect = l.getBoundingClientRect();
      const edgeSize = 40;
      if(e.clientY < lRect.top + edgeSize) {
        l.scrollTop -= 8;
      } else if(e.clientY > lRect.bottom - edgeSize) {
        l.scrollTop += 8;
      }
    }
  };
  
  const onPointerUp = e => {
    clearTimeout(longPressTimer);
    
    if(dragging && dragStarted) {
      const dropInfo = getDropInfo(e.clientX, e.clientY);
      if(dropInfo && dragData) {
        executeDrop(dragData, dropInfo);
      }
      
      if(dragData?.el) dragData.el.classList.remove('dragging-origin');
      clearDropTargets();
      removeGhost();
      l.classList.remove('scroll-lock');
      dragging = false;
      dragData = null;
      dragStarted = false;
      pressedEl = null;
      
      goDeckKeepScroll();
return;
    }
    
        if(dragging && !dragStarted) {
      if(dragData?.el) dragData.el.classList.remove('dragging-origin');
      removeGhost();
      l.classList.remove('scroll-lock');
      
      dragging = false;
      dragData = null;
      pressedEl = null;
      return;
    }
    
    if(!pressedEl || didLongPress) { pressedEl = null; return; }
    
    const item = pressedEl;
    pressedEl = null;
    
    if(e.target.closest('button, .sel-checkbox, .remove-x')) return;
    
    const dx = e.clientX - startX, dy = e.clientY - startY;
    if(M.hypot(dx, dy) > 15) return;
    
    const type = item.dataset.type;
    const id = item.dataset.id;
    
    if(selectionMode) {
      if(type === 'chapter') {
        if(selectedIds.has(id)) selectedIds.delete(id);
        else selectedIds.add(id);
        goDeck(false);
      } else if(type === 'group') {
  if(expandedFolders.has(id)) expandedFolders.delete(id);
  else expandedFolders.add(id);
  goDeckKeepScroll();
}
    } else {
      if(type === 'group') {
        openGrp(sub, id);
      } else {
        goChapter(id);
      }
    }
  };
  
  const onPointerCancel = () => {
    clearTimeout(longPressTimer);
    if(dragging) {
      if(dragData?.el) dragData.el.classList.remove('dragging-origin');
      clearDropTargets();
      removeGhost();
      l.classList.remove('scroll-lock');
    }
    dragging = false;
    dragData = null;
    dragStarted = false;
    pressedEl = null;
  };
  
  l.addEventListener('pointerdown', onPointerDown);
  l.addEventListener('pointermove', onPointerMove, {passive: false});
  l.addEventListener('pointerup', onPointerUp);
  l.addEventListener('pointercancel', onPointerCancel);
}

function openGrp(s,gid){ const g=findGrp(s,gid); if(g){State.virtualChapter=buildVirt(s,g);goChapter(State.virtualChapter.id)} }
D.addEventListener('pointerup', (e) => {
    if(!selectionMode) return;
    const deckItem = e.target.closest('.deck-item');
    const fab = e.target.closest('.fab-confirm, .fab-cancel');
    if(!deckItem && !fab) {
      exitSelectionMode();
    }
  });
function goChapter(id,push=true){
  safeCloseLB(); Media.revokeAll(); clearMathCache(); if(push)Nav.push(); State.view='chapter'; State.chapterId=id; const c=getCh(id); if(!c){Nav.back();return} setTop({title:c.title}); updRevBar(c); hideRevAct(); const k=c.stats.gradeCounts||getLive(c), sel=c.filters.grades, v=$('#view');
  const dailyCalc = getDailyGoalCalc(c);
  const last7=getLastN(c,7), lbls7=getLbls(7), max7=M.max(1,...last7);
  v.innerHTML=`<div class="card" style="flex:1;display:flex;flex-direction:column"><div class="section-title">${c.virtual?c.description:(getEmoji(c.title)?getEmoji(c.title)+' ':'')+'Statistiques'}</div><div class="stats-row"><div class="chart-wrap"><canvas id="gradeChart" width="140" height="140"></canvas></div><div class="bar7-side"><div style="font-size:10px;font-weight:700;color:var(--muted);text-transform:uppercase;letter-spacing:.3px;margin-bottom:2px">7 derniers jours</div>${last7.map((val,i)=>`<div class="bar7-row" data-day="${dayKeyIdx(7,i)}"><div class="bar7-label">${lbls7[i].substring(0,3)}</div><div class="bar7-track"><div class="bar7-fill" style="width:${max7?(val/max7*100):0}%"></div></div><div class="bar7-val">${val}</div></div>`).join('')}</div></div><div class="legend" id="legend">${GRADES.map(x=>`<div class="legend-item ${sel[x]?'':'inactive'}" data-key="${x}"><span class="dot ${GC[x]}"></span><span style="flex:1">${x[0].toUpperCase()+x.slice(1)}</span><b class="count">${k[x]}</b></div>`).join('')}</div><div class="stats-grid mt8"><div class="stat-card"><div class="stat-val">${k.unseen}</div><div class="stat-lbl">Non vues</div></div><div class="stat-card"><div class="stat-val">${c.cards.length}</div><div class="stat-lbl">Total</div></div><div class="stat-card"><div class="stat-val">${getTod(c)}</div><div class="stat-lbl">Aujourd'hui</div></div><div class="stat-card"><div class="stat-val">${getStreak(c)}j</div><div class="stat-lbl">üî• Streak</div></div><div class="stat-card"><div class="stat-val">${getSucc(c)}%</div><div class="stat-lbl">R√©ussite</div></div><div class="stat-card"><div class="stat-val">${get7dAvgMs(c)?M.round(get7dAvgMs(c)/100)/10+'s':'‚Äî'}</div><div class="stat-lbl">Moy. 7j</div></div></div><div class="mt8" style="padding:10px;background:var(--surface);border:1px solid var(--border);border-radius:10px;"><div style="display:flex;align-items:center;justify-content:space-between;"><span style="font-size:13px;font-weight:bold;color:var(--muted)">Date Limite:</span><input type="date" id="deadlineInput" class="input" style="width:auto;padding:4px 8px;" value="${c.deadline||''}"></div>${dailyCalc?`<div class="mt6" style="font-size:13px;color:var(--primary);display:flex;justify-content:space-between"><span>Objectif fix√©: <b>${c._goalCache?.size||dailyCalc.val}</b>/jour</span><span>Reste: <b>${cntAv(c)}</b> dispo</span></div>`:''}</div></div>`;
  drawChart('gradeChart',k,sel); $('#gradeChart').onclick=e=>hChartClk(e,'gradeChart',c); $$('.legend-item').forEach(el=>el.onclick=()=>updFilt(c,el.dataset.key)); $$('.bar7-row').forEach(el=>{el.onclick=()=>goDaily(c.id,el.dataset.day)});
  botAct.style.gridTemplateColumns=''; botAct.innerHTML=`<button class="action btn" id="cardsBtn">Cartes</button><button class="action btn" id="settingsBtn">Param√®tres</button>`; $('#cardsBtn').onclick=()=>goCards(State.chapterId); $('#settingsBtn').onclick=()=>openSet(State.chapterId);
  if(isMathChapter()){const det=data.app.prefs.mathDetail;botAct.innerHTML=`<button class="action btn" id="cb2">Cartes</button><button class="action btn ${det?'btn--primary':''}" id="db2">${det?'‚úì ':''}D√©tail</button><button class="action btn" id="sb2">Param√®tres</button>`;botAct.style.gridTemplateColumns='1fr 1fr 1fr';$('#cb2').onclick=()=>goCards(State.chapterId);$('#sb2').onclick=()=>openSet(State.chapterId);$('#db2').onclick=()=>{data.app.prefs.mathDetail=!data.app.prefs.mathDetail;debouncedSave();goChapter(c.id,false)};}
  $('#deadlineInput').onchange = (e) => { const val = e.target.value; if (c.virtual && c._groupId) { const g = findGrp(getSub(), c._groupId); if (g) g.deadline = val; } else { c.deadline = val; } debouncedSave(); goChapter(c.id, false); };
}
function updRevBar(c){ const n=cntAv(c); setBot({actions:!0,revision:!0,sz:c.settings.sessionSize,en:c.cards.length>0,av:n,cid:c.id}) }

async function goCards(cid,push=true){
  safeCloseLB(); Media.revokeAll(); if(push)Nav.push(); State.view='cards'; State.chapterId=cid; 
  const c=getCh(cid), pool=c.cards.filter(x=>c.filters.grades[x.grade||'unseen']), v=$('#view'); 
  setTop({title:`${c.title} ‚Ä¢ Cartes`}); setBot({actions:!1,revision:!1}); hideRevAct();
  v.innerHTML=`<div style="flex:1;display:flex;flex-direction:column;min-height:0"><div style="flex-shrink:0"><div class="section-title">Cartes (${pool.length})</div><div style="margin-bottom:10px"><input type="text" id="cardSearch" class="input" placeholder="Rechercher..." autocomplete="off" spellcheck="false"></div></div><div id="cardsGrid" class="scroll-y" style="flex:1;min-height:0;padding-right:4px"><div class="cards-grid" id="gridCont"></div></div></div>`;

  const renderCards = async (q='') => {
    const norm = s => s.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, ""), cleanQ = norm(q);
    let filtered = [];
    if (!cleanQ) { filtered = pool; } else {
        const scored = pool.map(x => {
            const {f,b} = getSides(x,c); const tf = norm(f); const tb = norm(b);
            const fStart = tf.startsWith(cleanQ), bStart = tb.startsWith(cleanQ), fIn = tf.includes(cleanQ), bIn = tb.includes(cleanQ);
            if (!fIn && !bIn) return null;
            let score = 2; let len = 100000; 
            if (fStart || bStart) { score = 1; len = Math.min(fStart ? tf.length : 100000, bStart ? tb.length : 100000); } else { score = 2; len = Math.min(fIn ? tf.length : 100000, bIn ? tb.length : 100000); }
            return { card: x, score, len };
        }).filter(x => x !== null);
        scored.sort((a, b) => { if (a.score !== b.score) return a.score - b.score; return a.len - b.len; });
        filtered = scored.map(s => s.card);
    }
    const grid = $('#gridCont'); grid.innerHTML = '';
    if(filtered.length === 0) { grid.innerHTML = `<div class="muted center" style="grid-column:1/-1;padding:20px">Aucune carte trouv√©e.</div>`; } 
    else {
       filtered.forEach(x => {
          const {f,b} = getSides(x,c), el = D.createElement('div');
          el.className = `card-block grade-${x.grade||'unseen'}`; el.dataset.id = x.id;
          const msC=getMathSimple(x), bContent=(!data.app.prefs.mathDetail&&msC)?formatText(msC):formatText(b);
          el.innerHTML = `<div class="term">${formatText(f)}</div><div class="definition">${bContent}</div>${x.avgMs?`<div class="cb-time">${fmtDur(x.avgMs)}</div>`:''}`;
          grid.appendChild(el);
       });
    }
    await Media.resolve(grid); await tsLat(grid);
  };
  await renderCards(); 
  $('#cardSearch').oninput = (e) => renderCards(e.target.value);
  $('#cardsGrid').onclick=e=>{ const b=e.target.closest('.card-block'); if(b){ $$('.card-block').forEach(x=>{if(x!==b)x.classList.remove('flipped')}); b.classList.toggle('flipped'); } };
}

async function goDaily(cid,k,push=true){
  safeCloseLB(); Media.revokeAll(); if(push)Nav.push(); State.view='daily'; State.chapterId=cid; State.dailyKey=k; const c=getCh(cid), sub=getSub(); setTop({title:`Activit√© ‚Ä¢ ${fmtDayFR(k)}`}); setBot({actions:!1,revision:!1});
  const log=c.virtual?(findGrp(sub,c._groupId)?getLogGrp(sub,findGrp(sub,c._groupId),k):[]):(c.stats.dailyLog[k]||[]), v=$('#view'); if(!log.length){v.innerHTML=`<div class="card"><div class="section-title">Activit√© ${fmtDayFR(k)}</div><div class="muted">Aucune donn√©e.</div></div>`;return}
  log.sort((a,b)=>a.ts-b.ts); const byC=new Map(); for(const e of log){const cur=byC.get(e.cardId)||{f:e.prev,l:e.next,ts:e.ts,lts:e.ts,_c:e._chapId};if(e.ts>cur.lts){cur.l=e.next;cur.lts=e.ts}byC.set(e.cardId,cur)}
  const rows=[...byC].map(([id,i])=>{const ch=c.virtual?_real(i._c):c,card=ch.cards.find(x=>x.id===id);return card?{t:formatText(getSides(card,ch).f),d:formatText(getSides(card,ch).b),b:i.f,a:i.l}:null}).filter(Boolean);
  v.innerHTML=`<div class="card" style="flex:1;display:flex;flex-direction:column;min-height:0"><div class="section-title">Activit√© ${fmtDayFR(k)}</div><div id="dayL" class="scroll-y" style="flex:1"><div class="list">${rows.map(r=>`<div class="grid2"><div class="card-block grade-${r.b}"><div class="term">${r.t}</div><div class="definition">${r.d}</div></div><div class="card-block grade-${r.a}"><div class="term">${r.t}</div><div class="definition">${r.d}</div></div></div>`).join('')}</div></div></div>`;
  await Media.resolve(v); await tsLat(v); $('#dayL').onclick=e=>{const b=e.target.closest('.card-block');if(b)b.classList.toggle('flipped')}
}
function getLogGrp(s,g,k){ return g.chapIds.flatMap(cid=>{const ch=s.chapters.find(c=>c.id===cid);return(ch?.stats?.dailyLog?.[k]||[]).map(e=>({...e,_chapId:cid}))}) }

function goReview(push=true){ safeCloseLB(); Media.revokeAll(); if(push)Nav.push(); State.view='review'; setTop({title:'R√©vision'}); setBot({actions:!1,revision:!0}); $('#revisionBar').style.display='none'; $('#reviewActionsBar').style.display='block'; $('#app').classList.toggle('focus-mode', data.app.prefs.focusMode); renRev() }

function renRev(){
  const v=$('#view'), r=State.review, {card,chap}=getCur(), idx=r.index+1, tot=r.queue.length, {f,b}=getSides(card,chap), ff=chap.settings.reviewOrder!=='back-first';
  const ms=getMathSimple(card), fT=formatText(f), bT=(!data.app.prefs.mathDetail&&ms)?formatText(ms):formatText(b), progress=((r.index)/tot)*100;
  const undoBtn = r.history.length ? `<button id="undoBtn" style="background:0 0;border:0;color:var(--muted);font-size:18px;padding:0 8px;cursor:pointer">‚Ü∫</button>` : '';
  
  v.innerHTML=`<div class="review-wrap">
    <div class="progress-bar" style="width:${progress}%"></div>
    <div class="review-top"><div style="display:flex;align-items:center">${undoBtn} ${r.mode==='multi'?'Multi ‚Ä¢ '+chap.title:chap.title}</div><div>${idx} / ${tot}</div></div>
    <div class="review-card"><div class="review-scroller">${!r.flipped ? `<div class="term" data-face="${ff?'front':'back'}">${fT}</div>` : `<div class="stack"><div class="term" data-face="front">${fT}</div><div class="definition" data-face="back" style="margin-top:20px;padding-top:20px;border-top:1px dashed var(--border)">${bT}</div></div>`}</div></div>
  </div>`;
  
  const scroller = v.querySelector('.review-scroller');
  const finishSetup = () => { Media.resolve(v); initGest(); bindSwipeNav(); };
  if(scroller) tsLat(scroller).then(finishSetup); else finishSetup();
  if(r.history.length) $('#undoBtn').onclick = undoRev; 
  
  let lastTap = 0;
  $('.review-scroller').addEventListener('click', e => {
    if(e.target.closest('img')) return;
    const now = Date.now();
    if(now - lastTap < 300 && !r.flipped) { haptic('light'); r.flipped = true; renRev(); }
    lastTap = now;
  });

  const bar=$('#reviewActionsBar');
  if(!r.flipped){
      bar.innerHTML=`<button class="btn btn--solid btn--primary" id="flipBtn">Retourner</button>`;
      $('#flipBtn').onclick=()=>{haptic('light');r.flipped=!0;renRev()}
  } else {
      bar.innerHTML=`<div class="row-4">${['echec','difficile','bien','facile'].map(g=>`<button class="btn ${GB[g]}" id="g_${g}">${g}</button>`).join('')}</div>`;
      ['echec','difficile','bien','facile'].forEach(g=>$('#g_'+g).onclick=()=>subG(g))
  }
}

function goRecap(push=true){
  safeCloseLB(); Media.revokeAll(); if(push)Nav.push(); State.view='recap'; const c=getCh(State.review.chapterId)||State.virtualChapter||getCh(State.review.multiChaps[0]); setTop({title:'R√©capitulatif'}); setBot({actions:!1,revision:!1}); hideRevAct();
  const dur=(State.review.answers||[]).reduce((s,a)=>s+(a.ms||0),0), n=State.review.answers.length;
  $('#view').innerHTML=`<div class="card recap" style="flex:1"><div><h2>R√©capitulatif</h2><div class="subtitle">${c.title}</div></div><div class="grid2"><div class="stat"><div class="label">Moy. 7j</div><div class="val">${get7dAvg(c)}</div></div><div class="stat"><div class="label">Changement</div><div class="val">${getTodCh(c).total>0?M.round(getTodCh(c).changed/getTodCh(c).total*100):0}%</div></div><div class="stat"><div class="label">Fait</div><div class="val">${getTod(c)}</div></div></div><div class="grid2"><div class="stat"><div class="label">Session</div><div class="val">${n}</div></div><div class="stat"><div class="label">Dur√©e</div><div class="val">${fmtDur(dur)}</div></div></div><div class="cta"><button class="btn btn--solid btn--primary" id="contBtn">Continuer</button></div></div>`;
  $('#contBtn').onclick=()=>startRev(c.id,!1,true)
}
function continueOrNew(cid,queue,mode,push,isCont,extras={}){
  if(isCont&&State.review){State.review.queue.push(...queue);State.review.index++;State.review.flipped=!1;State.review.cardStart=Date.now();State.review.end=null}
  else State.review={chapterId:cid,queue,index:0,flipped:!1,answers:[],history:[],start:Date.now(),end:null,cardStart:Date.now(),...extras};
  goReview(push)
}
function startRev(cid,push=true,isCont=false){
  if(!cid)return;const c=getCh(cid);
  if(c.virtual&&c._ids)return startRevMulti(c._ids,c.id,c.filters,push,isCont);
  if(c.deadline){const ds=getDayStart();if(!c._goalCache||c._goalCache.day!==ds){const calc=getDailyGoalCalc(c);c._goalCache={day:ds,size:calc?.val||10,pool:calc?.pool||0}}c.settings.sessionSize=c._goalCache.size}
  let pool=c.cards.filter(x=>c.filters.grades[x.grade||'unseen']);
  if(isCont&&State.review?.queue){const seen=new Set(State.review.queue);pool=pool.filter(x=>!seen.has(x.id))}
  if(!pool.length){alert('Plus de cartes disponibles dans ce filtre.');return}
  c.lastUsed=Date.now();saveData();
  continueOrNew(cid,bldQ(c,pool,c.settings.sessionSize).map(x=>x.id),null,push,isCont)
}
function startRevMulti(ids,vid,flt,push=true,isCont=false){
  const all=ids.map(_real).filter(Boolean),pool=[];
  const seen=isCont&&State.review?new Set(State.review.queue.map(i=>i.cardId)):new Set();
  all.forEach(ch=>ch.cards.forEach(c=>{if(flt.grades[c.grade||'unseen']&&!seen.has(c.id))pool.push({chapId:ch.id,card:c})}));
  if(!pool.length){alert('Plus de cartes disponibles.');return}
  const wt={unseen:6,echec:5,difficile:3.5,bien:2,facile:1};
  const scored=pool.map(i=>{const g=i.card.grade||'unseen',base=wt[g]||1,due=i.card.dueAt>0?(Date.now()-i.card.dueAt>0?1+M.min(3,(Date.now()-i.card.dueAt)/864e5):.85):1.15;return{chapId:i.chapId,cardId:i.card.id,w:base*due*(1+(1-(i.card.perfEma||.5))*1.6)*(1+M.min(2,(i.card.avgMs||0)/3000))*(.9+M.random()*.2)}}).sort((a,b)=>b.w-a.w);
  const sz=M.round(all.reduce((s,c)=>s+(c.settings.sessionSize||10),0)/all.length)||10;
  if(vid.startsWith('group-')){const g=findGrp(getSub(),vid.replace('group-',''));if(g){g.lastUsed=Date.now();saveData()}}
  continueOrNew(vid,scored.slice(0,sz),null,push,isCont,{mode:'multi',multiChaps:ids.slice()})
}

function bldQ(c,pool,sz){
  const sh=a=>{for(let i=a.length-1;i>0;i--){const j=M.floor(M.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}return a};
  const nc=[], lc=[], dr=[], ot=[];
  pool.forEach(x=>{
      const g=x.grade||'unseen';
      if(g==='unseen') nc.push(x); else if(g==='echec'||g==='difficile') lc.push(x); else if(x.dueAt<=Date.now()) dr.push(x); else ot.push(x);
  });
  return [...sh(lc),...sh(dr),...sh(nc),...sh(ot)].slice(0,sz)
}

function getCur(){ const r=State.review; if(!r||r.index<0||r.index>=r.queue.length)return{card:null,chap:null}; if(r.mode==='multi'){const i=r.queue[r.index];if(!i)return{card:null,chap:null};const ch=_real(i.chapId);if(!ch)return{card:null,chap:null};return{card:ch.cards.find(x=>x.id===i.cardId)||null,chap:ch}}else{const ch=getCh(r.chapterId);if(!ch)return{card:null,chap:null};return{card:ch.cards.find(x=>x.id===r.queue[r.index])||null,chap:ch}} }

function undoRev(){
  const r = State.review; if(!r.history.length) return;
  const snap = r.history.pop(); r.index = snap.idx;
  const {card, chap} = getCur(); Object.assign(card, snap.cardState); chap.stats = snap.statsState;
  if(r.answers.length > snap.ansIdx) r.answers.splice(snap.ansIdx);
  r.flipped = false; 
  saveData(); renRev();
}
  
function subG(nxt){
  const r=State.review, now=Date.now(), {card,chap}=getCur(); if(!card||!chap){goDeck(!1);return}
  haptic(nxt === 'facile' ? 'success' : nxt === 'echec' ? 'error' : 'light'); 

  r.history.push({ idx: r.index, cardState: deepClone(card), statsState: deepClone(chap.stats), ansIdx: r.answers.length });
  const ms=M.max(0,now-(r.cardStart||now)), prev=card.grade||'unseen', wZ=!chap.stats.gradeCounts[nxt];
  card.grade=nxt; syncG(chap); card.perfEma=(1-.3)*(card.perfEma??.5)+.3*(nxt==='facile'?1:nxt==='bien'?0.75:nxt==='difficile'?0.35:0);
  schNx(card,nxt,now); card.lastReviewed=now; card.lastMs=ms; card.avgMs=card.avgMs?M.round(card.avgMs*.7+ms*.3):ms; card.timesReviewed++;
  if(isSucc(nxt))card.successes++;else card.failures++; chap.stats.totalReviews++; const k=todayKey();
  chap.stats.dailyReviews[k]=(chap.stats.dailyReviews[k]||0)+1; chap.stats.dailyDurMs[k]=(chap.stats.dailyDurMs[k]||0)+ms; chap.stats.dailyDurCount[k]=(chap.stats.dailyDurCount[k]||0)+1;
  const dc=chap.stats.dailyChanges[k]||{changed:0,total:0}; dc.total++; if(prev!==nxt)dc.changed++; chap.stats.dailyChanges[k]=dc;
  (chap.stats.dailyLog[k]=chap.stats.dailyLog[k]||[]).push({cardId:card.id,prev,next:nxt,ms,ts:now}); if(wZ&&nxt!=='unseen')chap.filters.grades[nxt]=!0;
  r.answers.push({cardId:card.id,prev,next:nxt,ms});
  if(r.index<r.queue.length-1){r.index++;r.flipped=!1;r.cardStart=Date.now();debouncedSave();renRev()}else{r.end=Date.now();debouncedSave();goRecap(!1)}
}
function schNx(c,g,now){
  const q={'facile':5,'bien':4,'difficile':2,'echec':1}[g]||0; let ef=c.ef||2.5; ef=ef+(0.1-(5-q)*(0.08+(5-q)*0.02)); if(ef<1.3)ef=1.3; c.ef=ef;
  if(q<3){c.intervalDays=(g==='echec')?0.02:0.5;c.streak=(c.streak<=0?c.streak-1:-1)}else{c.intervalDays=c.intervalDays<.001?1:c.intervalDays<1.5?6:M.round(c.intervalDays*ef);c.streak=(c.streak>=0?c.streak+1:1)}
  c.streak=clamp(c.streak,-8,12); c.dueAt=now+c.intervalDays*864e5
}

const getLive=c=>{const o=GRADE_INIT();c.cards.forEach(x=>o[x.grade||'unseen']++);return o},syncG=c=>c.stats.gradeCounts=getLive(c),getTod=c=>c.stats.dailyReviews[todayKey()]||0,getTodCh=c=>c.stats.dailyChanges[todayKey()]||{changed:0,total:0},cntAv=c=>c.cards.filter(x=>c.filters.grades[x.grade||'unseen']).length,getSucc=c=>{const k=c.stats.gradeCounts,g=k.bien+k.facile,t=g+k.echec+k.difficile;return t?M.round(g/t*100):0},get7dAvgMs=c=>{const b=new Date();let s=0,n=0;for(let i=0;i<7;i++){const d=new Date(b);d.setDate(b.getDate()-i);const k=dateKey(d);s+=(c.stats.dailyDurMs[k]||0);n+=(c.stats.dailyDurCount[k]||0)}return n?M.round(s/n):0},get7dAvg=c=>{const b=new Date(),a=[];for(let i=0;i<7;i++){const d=new Date(b);d.setDate(b.getDate()-i);a.push(c.stats.dailyReviews[dateKey(d)]||0)}return M.round(avg(a))},daysAgo=(n,i)=>{const d=new Date();d.setDate(d.getDate()-((n-1)-i));return d},getLastN=(c,n)=>Array.from({length:n},(_,i)=>c.stats.dailyReviews[dateKey(daysAgo(n,i))]||0),getLbls=n=>Array.from({length:n},(_,i)=>['Dim','Lun','Mar','Mer','Jeu','Ven','Sam'][daysAgo(n,i).getDay()]),dayKeyIdx=(n,i)=>dateKey(daysAgo(n,i));

function drawChart(id,k,sel){ const el=D.getElementById(id); if(!el)return; const ctx=el.getContext('2d'), w=140, h=140, cx=70, cy=70, R=64, r=40; ctx.clearRect(0,0,w,h); const segs=[{k:'unseen',c:'#9ca3af'},{k:'echec',c:'#ef4444'},{k:'difficile',c:'#f59e0b'},{k:'bien',c:'#3b82f6'},{k:'facile',c:'#22c55e'}], tot=segs.reduce((s,x)=>s+(k[x.k]||0),0), arcs=[]; 
 if(!tot){ctx.beginPath();ctx.arc(cx,cy,R,0,6.28);ctx.lineWidth=24;ctx.strokeStyle='#cbd5e1';ctx.stroke();ChartHit[id]={cx,cy,innerR:r,outerR:R,arcs:[]};return} let start=-1.57; segs.forEach(s=>{const v=k[s.k];if(!v)return;const ang=(v/tot)*6.28,end=start+ang,act=!sel||sel[s.k];ctx.beginPath();ctx.arc(cx,cy,52,start,end);ctx.lineWidth=24;ctx.strokeStyle=s.c;ctx.globalAlpha=act?0.9:0.2;ctx.stroke();ctx.globalAlpha=1;arcs.push({key:s.k,start,end});start=end}); ctx.fillStyle='#0ea5e9'; ctx.font='bold 15px sans-serif'; ctx.textAlign='center'; ctx.fillText(tot,cx,cy+4); ChartHit[id]={cx,cy,innerR:r,outerR:R,arcs} }
function hChartClk(e,id,ch){ const h=ChartHit[id]; if(!h)return; const r=e.target.getBoundingClientRect(), dx=(e.clientX-r.left)*(180/r.width)-h.cx, dy=(e.clientY-r.top)*(180/r.height)-h.cy, d=M.hypot(dx,dy); if(d<h.innerR||d>h.outerR)return; let a=M.atan2(dy,dx); if(a<-1.57)a+=6.28; const hit=h.arcs.find(s=>a>=s.start&&a<=s.end); if(hit)updFilt(ch,hit.key) }

function togFilt(c,k){ 
  const s=c.filters.grades, keys=Object.keys(s), actCnt=keys.reduce((n,x)=>n+(s[x]?1:0),0);
  if(actCnt===keys.length){ keys.forEach(x=>s[x]=(x===k)); }
  else if(actCnt===1&&s[k]){ keys.forEach(x=>s[x]=!0); }
  else { s[k]=!s[k]; if(!s[k]&&actCnt===1) s[k]=!0; }
}
const getPreviewTxt=()=>{const s=data.subjects.find(s=>s.title.toLowerCase().includes('physique'))||data.subjects[0],a=(s?.chapters||[]).flatMap(c=>c.cards).filter(c=>!c.front.includes('<img')&&!c.back.includes('<img'));if(!a.length)return{f:"La constante de Planck",b:"h = 6,626 x 10‚Åª¬≥‚Å¥ J.s"};const r=a[M.floor(M.random()*a.length)];return{f:r.front.replace(/<br>/g,' '),b:r.back.replace(/<br>/g,' ')}};
function openSet(cid,push=true){
  safeCloseLB(); Media.revokeAll(); if(!cid)cid=State.chapterId; const c=getCh(cid); if(!c)return; if(push)Nav.push(); State.view='settings'; setTop({title:'Param√®tres'}); setBot({actions:!1}); hideRevAct(); const v=$('#view'), P=data.app.prefs;
  const isDark = data.app.theme==='dark'; const prev = getPreviewTxt();
  
  const sCtrl=(sId,subId,addId,valId,val,sfx='')=>`<div class="s-control"><button class="step-btn" id="${subId}">-</button><div class="s-slider-container" style="margin:0 10px;flex:1"><input type="range" class="s-slider" id="${sId}" min="12" max="72" value="${val}"></div><button class="step-btn" id="${addId}">+</button></div>`;
  const swatches=['indigo','blue','teal','emerald','rose','amber','violet'].map(x=>`<button class="swatch ${P.accent===x?'is-active':''}" data-accent="${x}" style="--sw:var(--${x==='indigo'?'primary':x})"></button>`).join('');
  const sect=(t,body)=>`<div class="settings-section"><div class="section-title">${t}</div>${body}</div>`;
  v.innerHTML=`<div class="settings-page scroll-y" style="flex:1">
    <div class="settings-hero">Param√®tres</div>
    ${sect('Chapitre',
      sRow('rowTitle','‚úèÔ∏è','Nom du chapitre',c.title,sChev,1)+
      sRow('rowEmoji','üòä','Emoji','',sVal(c.emoji||getEmoji(c.title)||'Aucun')+sChev,1)+
      sRow('rowLang','üîÑ','Ordre des langues',c.settings.langSwap?'Verso ‚Üí Recto':'Recto ‚Üí Verso',sChev,1)
    )}
    ${sect('Apparence',
      sRow('rowTheme','üåì','Mode sombre','',sToggle(isDark),1)+
      sRow('rowFocus','üéØ','Mode Immersion (Zen)','Interface invisible en r√©vision',sToggle(P.focusMode),1)+
      sRow('','üé®','Couleur','',`<div class="swatches">${swatches}</div>`)
    )}
    ${sect('Typographie (Aper√ßu direct)',
      `<div class="preview-box"><div class="preview-recto" id="preT"></div><div class="preview-verso" id="preD"></div></div>`+
      sRow('','Aa','Taille Recto','',sVal(P.fsTerm+'px').replace('s-value','s-value" id="valT'))+sCtrl('sldT','subT','addT','valT',P.fsTerm)+
      sRow('','Aa','Taille Verso','',sVal(P.fsDef+'px').replace('s-value','s-value" id="valD'))+sCtrl('sldD','subD','addD','valD',P.fsDef)
    )}
    ${sect('Session',
      sRow('','üìö','Taille session','Nombre de cartes par r√©vision',sVal(c.settings.sessionSize).replace('s-value','s-value" id="valS'))+sCtrl('sldS','subS','addS','valS',c.settings.sessionSize)
    )}
    ${sect('Donn√©es',
      sRow('rowExp','üì§','Exporter','Sauvegarder toutes les donn√©es',sChev,1)+
      sRow('rowImp','üì•','Importer','Restaurer une sauvegarde',sChev,1)+
      '<input type="file" id="impF" class="hidden">'
    )}
    ${sect('Zone dangereuse',
      sRow('rowRstC','üîÑ','R√©initialiser ce chapitre','Remettre toutes les cartes √† "Non vu"','',1)+
      `<div class="settings-row" id="rowRstA"><div class="s-icon danger">üí•</div><div class="s-label"><div class="s-title">R√©initialiser l'application</div><div class="s-sub">Supprimer toutes les donn√©es</div></div></div>`
    )}
    <div class="settings-footer">Flashcards v${APP_VER}<br><span style="opacity:.7;font-size:.9em">JB. C</span></div></div>`;

  const preBox = v.querySelector('.preview-box');
  $('#preT').innerHTML = formatText(prev.f); $('#preD').innerHTML = formatText(prev.b); Media.resolve(preBox); tsLat(preBox);
  const setupControl = (sldId, subId, addId, valId, obj, prop, suffix = '', cssVar = null, fontPrev = null) => {
      const sld = $(sldId), sub = $(subId), add = $(addId), val = $(valId), pre = fontPrev ? $(fontPrev) : null;
      const update = (v) => {
          v = parseInt(v); const min = parseInt(sld.min), max = parseInt(sld.max); if(v < min) v = min; if(v > max) v = max;
          obj[prop] = v; sld.value = v; val.textContent = v + suffix;
          if(cssVar) D.documentElement.style.setProperty(cssVar, v + 'px'); if(pre) pre.style.fontSize = v + 'px';
      };
      sld.oninput = () => update(sld.value); sld.onchange = () => { debouncedSave(); haptic('light'); };
      sub.onclick = (e) => { e.stopPropagation(); update(parseInt(sld.value) - 1); debouncedSave(); haptic('light'); };
      add.onclick = (e) => { e.stopPropagation(); update(parseInt(sld.value) + 1); debouncedSave(); haptic('light'); };
  };

  setupControl('#sldT', '#subT', '#addT', '#valT', P, 'fsTerm', 'px', '--fs-term', '#preT');
  setupControl('#sldD', '#subD', '#addD', '#valD', P, 'fsDef', 'px', '--fs-def', '#preD');
  setupControl('#sldS', '#subS', '#addS', '#valS', c.settings, 'sessionSize', '');

  $('#rowTitle').onclick=()=>{ const t=prompt('Nouveau titre:', c.title); if(t && t.trim()){ const newTitle = t.trim(); if(c.virtual && c._groupId){ const g = findGrp(getSub(), c._groupId); if(g) g.title = newTitle; c.title = newTitle; } else { const real = _real(c.id); if(real) real.title = newTitle; c.title = newTitle; } updChDesc(c); debouncedSave(); openSet(cid, !1); } };
  $('#rowEmoji').onclick=()=>{ const emojiActuel = c.emoji || getEmoji(c.title) || ''; const e = prompt('Emoji (laissez vide pour l\'√©moji par d√©faut) :', emojiActuel); if (e !== null) { const newEmoji = e.trim(); if (c.virtual && c._groupId) { const g = findGrp(getSub(), c._groupId); if (g) g.emoji = newEmoji; c.emoji = newEmoji; } else { const real = _real(c.id); if (real) real.emoji = newEmoji; c.emoji = newEmoji; } updChDesc(c); debouncedSave(); openSet(cid, !1); } };
  $('#rowLang').onclick=()=>{c.settings.langSwap=!c.settings.langSwap;debouncedSave();openSet(cid,!1)};
  $('#rowTheme').onclick=()=>{data.app.theme=isDark?'light':'dark';debouncedSave();applyTh();openSet(cid,!1)};
  $('#rowFocus').onclick=()=>{P.focusMode=!P.focusMode;debouncedSave();openSet(cid,!1)};
  $$('.swatch').forEach(b=>b.onclick=e=>{ e.stopPropagation(); P.accent=b.dataset.accent; debouncedSave(); applyUI(); $$('.swatch').forEach(x=>x.classList.toggle('is-active',x===b)); $$('.s-icon.dynamic').forEach(icon => { icon.style.background = `var(--primary)`; }); haptic('light'); });
  $('#rowExp').onclick=()=>{const a=D.createElement('a');a.href=URL.createObjectURL(new Blob([JSON.stringify(data)],{type:'application/json'}));a.download=`flashcards-${dateKey(new Date())}.json`;a.click()};
  $('#rowImp').onclick=()=>$('#impF').click();
  $('#impF').onchange=async e=>{if(confirm("√âcraser toutes les donn√©es ?")){data=JSON.parse(await e.target.files[0].text());upgrade();applyTh();applyUI();saveData();goDeck(!1)}};
  $('#rowRstC').onclick=()=>{if(confirm('R√©initialiser ce chapitre ?')){c.cards.forEach(x=>Object.assign(x,{grade:'unseen',timesReviewed:0,ef:2.5,intervalDays:0,dueAt:0,streak:0}));c.stats=mkStats(c.cards.length);saveData();openSet(cid,!1)}};
  $('#rowRstA').onclick=async()=>{if(confirm('‚ö†Ô∏è Supprimer TOUTES les donn√©es ?')){await Media.clearAll();LS.removeItem(KEY);location.reload()}};
}

function initGest(){ const s=$('.review-scroller'); if(s)$$('img',s).forEach(i=>i.onclick=e=>{e.preventDefault();openLB(i,s)}); bindSz() }
function bindSz() {
    const elements = $$('.review-card .term, .review-card .definition'); const getDist = (t) => Math.hypot(t[0].pageX - t[1].pageX, t[0].pageY - t[1].pageY);
    elements.forEach(el => {
        let startDist = 0; let startVal = 0; const isTerm = el.classList.contains('term');
        el.addEventListener('touchstart', (e) => { if (e.touches.length === 2) { if (e.cancelable) e.preventDefault(); startDist = getDist(e.touches); startVal = isTerm ? data.app.prefs.fsTerm : data.app.prefs.fsDef; } }, { passive: false });
        el.addEventListener('touchmove', (e) => { if (e.touches.length === 2 && startDist > 0) { if (e.cancelable) e.preventDefault(); const dist = getDist(e.touches); const scale = dist / startDist; const newVal = clamp(Math.round(startVal * scale), 12, 90); if (isTerm) { data.app.prefs.fsTerm = newVal; } else { data.app.prefs.fsDef = newVal; } applyUI(); } }, { passive: false });
        el.addEventListener('touchend', (e) => { if (e.touches.length < 2 && startDist > 0) { startDist = 0; saveData(); } });
    });
}

function applyTh(){ D.documentElement.dataset.theme=data.app.theme }
function applyUI(){ const p=data.app.prefs; D.documentElement.style.setProperty('--fs-term',p.fsTerm+'px'); D.documentElement.style.setProperty('--fs-def',p.fsDef+'px'); const pl={indigo:['#6366f1','#5457e6'],blue:['#3b82f6','#2563eb'],teal:['#14b8a6','#0d9488'],emerald:['#10b981','#059669'],rose:['#f43f5e','#e11d48'],amber:['#f59e0b','#d97706'],violet:['#8b5cf6','#7c3aed']}, c=pl[p.accent]||pl.indigo; D.documentElement.style.setProperty('--primary',c[0]); D.documentElement.style.setProperty('--primary-600',c[1]) }
function reconcile(){ const c=buildCanon(), o=data.subjects||[], oMap=Object.fromEntries(o.map(s=>[s.title,s])); data.subjects=c.map(x=>{const old=oMap[x.title]||{}, ocMap=Object.fromEntries((old.chapters||[]).map(c=>[c.title,c])); const chs=x.chapters.map(nc=>{const oc=ocMap[nc.title]; if(!oc)return nc; const cardMap=Object.fromEntries(oc.cards.map(c=>[extractId(c.id),c])); return{...nc,stats:{...oc.stats},cards:nc.cards.map(cd=>{const oldC=cardMap[extractId(cd.id)]; return oldC?{...cd,grade:oldC.grade,ef:oldC.ef,intervalDays:oldC.intervalDays,dueAt:oldC.dueAt}:cd})}}); return{...x,chapters:chs,groups:old.groups||[]}}); o.forEach(x=>{if(!data.subjects.find(z=>z.id===x.id))data.subjects.push(x)}); if(!data.subjects.find(x=>x.id===data.app.currentSubjectId))data.app.currentSubjectId=data.subjects[0].id }
function upgrade(){ 
  if(!data.app) data.app = {theme:'dark'}; 
  data.app.prefs = {fsTerm:22, fsDef:24, accent:'indigo', radius:14, ...(data.app.prefs||{})}; 
  if(data.app.prefs.mathDetail === undefined) data.app.prefs.mathDetail = false; 
  data.subjects.forEach(s => {
    ensGrps(s).forEach(g => {
      if(!g.childGroupIds) g.childGroupIds = [];
      if(!g.parentGroupId) g.parentGroupId = null;
      if(!g.chapIds) g.chapIds = [];
    });
    valGrps(s); 
    s.emoji = s.emoji || ''; 
    s.chapters.forEach(c => {
      c.emoji = c.emoji || ''; 
      updChDesc(c); 
      c.stats.dailyLog = c.stats.dailyLog || {}; 
      syncG(c);
    });
  });
  ensureMathGrouped();
}

function ensureMathGrouped(){
  const mathSub = data.subjects.find(s => s.title.toLowerCase() === 'maths');
  if(!mathSub || mathSub.chapters.length < 2) return;
  
  const isExcluded = c => /travail/i.test(c.title);
  const courseChaps = mathSub.chapters.filter(c => !isExcluded(c));
  
  const grps = ensGrps(mathSub);
  const existing = grps.find(g => g.id === 'g-math-all');
  
  if(existing) {
    const alreadyIn = new Set();
    getAllChapIdsRecursive(mathSub, 'g-math-all').forEach(id => alreadyIn.add(id));
    for(const c of courseChaps) {
      if(!alreadyIn.has(c.id)) existing.chapIds.push(c.id);
    }
    const excludedIds = new Set(mathSub.chapters.filter(isExcluded).map(c => c.id));
    existing.chapIds = existing.chapIds.filter(id => !excludedIds.has(id));
  } else {
    grps.push({
      id: 'g-math-all',
      chapIds: courseChaps.map(c => c.id),
      childGroupIds: [],
      parentGroupId: null,
      createdAt: Date.now(),
      title: 'R√©sum√© de Cours',
      emoji: 'üìñ',
      lastUsed: Date.now()
    });
  }
  
  valGrps(mathSub);
}

async function init(){
  Media.open();
  setInterval(saveData, 30000);

  try {
    const r = await fetch('math.md');
    if(r.ok) dataMATH = parseMathData(await r.text());
  } catch(e){ console.warn('math.md non trouv√©, fallback vide'); }

  try {
    data = loadData();
    if(data.app?.version !== APP_VER){ reconcile(); data.app.version = APP_VER; saveData(); }
    pruneStats(); upgrade(); applyTh(); applyUI(); Nav.clear(); goDeck(!1);
  } catch(e) {
    console.error('Init error, resetting:', e);
    localStorage.removeItem(KEY);
    data = loadData();
    upgrade(); applyTh(); applyUI(); Nav.clear(); goDeck(!1);
  }
}

init();
</script>
</body>
</html>
